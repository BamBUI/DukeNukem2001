	TITLE	D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DD@BIGB@D?3?2Games?2duke_nukem_forever?2Hack@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@MBIJ@Cannot?5init?5CPrintfT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@CDMH@Unable?5to?5lock?5vertex?5buffer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DK@KCID@D?3?2Games?2duke_nukem_forever?2Hack@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@NEML@Unable?5to?5unlock?5vertex?5buffer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@HNDD@Already?5in?5primitive?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DDMK@Not?5in?5primitive?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GDIC@bad?5primitive?5type?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@MEJC@VManager?3?3end_prim?3?5DrawPrimitiv@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DC@MINH@D?3?2Games?2duke_nukem_forever?2Hack@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XListState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XListState@@QAE@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemStats@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_locked@XMutex@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_d_assert@@YAXPBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FindState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1VidTex@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GVidTex@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VidView@@QAE@KKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1VidView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GVidView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1VidIf@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetColor@VidIf@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlatColor@VidIf@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BeginScene@VidIf@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndScene@VidIf@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Diags@VidIf@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BeginLines@VidIf@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndLines@VidIf@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GVidIf@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXPLANE@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?realloc@PrimBuffer@@AAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reset@PrimBuffer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@VBuffer@@QAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@VBuffer@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckRoom@VManager@@IAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin_prim@VManager@@QAEPAUDxVertexT@@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end_prim@VManager@@QAEXPAUDxVertexT@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPrimBuffer@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PrimBuffer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set@XFontLetter@@QAEXMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get@XFontLetter@@QAEXPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set_drawable@XFontLetter@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_letter@XFont@@QAEXDPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_pitch@XFont@@QAEXPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_drawable@XFont@@QAEKD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GViewD3D@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ViewD3D@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$autoptr@VXImage@@@@QAEPAVXImage@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XList@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XList@VXStatistic@@@@QAEPAU_XPos@@PAVXStatistic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRingChain@VVBuffer@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VVidTexD3D@@@@QAE@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VVidTexD3D@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSysObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXFindLevel@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GVBuffer@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?new_node@?$XList@VXStatistic@@@@IAEPAUXNode@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXStatistic@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXFindLevel@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VVidTexD3D@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStrObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPathObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7VidTex@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7VidIf@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMemMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ViewD3D@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7XMutex@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7VidView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?_deb_rend@@3KC					; _deb_rend
PUBLIC	?_deb_val@@3KC					; _deb_val
PUBLIC	?_deb_x@@3MA					; _deb_x
PUBLIC	?_deb_y@@3MA					; _deb_y
PUBLIC	?_deb_width@@3MA				; _deb_width
PUBLIC	?_deb_height@@3MA				; _deb_height
_BSS	SEGMENT
?_deb_rend@@3KC DD 01H DUP (?)				; _deb_rend
?_deb_val@@3KC DD 01H DUP (?)				; _deb_val
?_deb_width@@3MA DD 01H DUP (?)				; _deb_width
?_deb_height@@3MA DD 01H DUP (?)			; _deb_height
_BSS	ENDS
_DATA	SEGMENT
_poly_clear DD	0ffH
?_deb_x@@3MA DD	0c2480000r			; -50	; _deb_x
?_deb_y@@3MA DD	0c2480000r			; -50	; _deb_y
_DATA	ENDS
PUBLIC	??2@YAPAXI@Z					; operator new
EXTRN	__imp_@xmalloc@4:NEAR
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_size$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 129  : __inline void *operator new(size_t size){return xmalloc(size);}

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _size$[ebp]
	call	DWORD PTR __imp_@xmalloc@4
	pop	ebp
	ret	0
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX@Z					; operator delete
EXTRN	__imp_@xfree@4:NEAR
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 130  : __inline void operator delete(void *ptr){xfree(ptr);}

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _ptr$[ebp]
	call	DWORD PTR __imp_@xfree@4
	pop	ebp
	ret	0
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??0ViewD3D@@QAE@PAVXWnd@@PAUIDirect3DDevice8@@KKK@Z ; ViewD3D::ViewD3D
PUBLIC	??0VidView@@QAE@KKK@Z				; VidView::VidView
PUBLIC	??_7ViewD3D@@6B@				; ViewD3D::`vftable'
PUBLIC	??_GViewD3D@@UAEPAXI@Z				; ViewD3D::`scalar deleting destructor'
PUBLIC	??_EViewD3D@@UAEPAXI@Z				; ViewD3D::`vector deleting destructor'
;	COMDAT ??_7ViewD3D@@6B@
; File D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.cpp
CONST	SEGMENT
??_7ViewD3D@@6B@ DD FLAT:??_EViewD3D@@UAEPAXI@Z		; ViewD3D::`vftable'
CONST	ENDS
_TEXT	SEGMENT
_Wnd$ = 8
_Dev$ = 12
_Width$ = 16
_Height$ = 20
_Bpp$ = 24
_this$ = -4
??0ViewD3D@@QAE@PAVXWnd@@PAUIDirect3DDevice8@@KKK@Z PROC NEAR ; ViewD3D::ViewD3D

; 19   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _Bpp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VidView@@QAE@KKK@Z			; VidView::VidView
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7ViewD3D@@6B@ ; ViewD3D::`vftable'

; 20   : 	wnd=Wnd;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Wnd$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 21   : 	dev=Dev;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Dev$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 22   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0ViewD3D@@QAE@PAVXWnd@@PAUIDirect3DDevice8@@KKK@Z ENDP ; ViewD3D::ViewD3D
_TEXT	ENDS
PUBLIC	??_7VidView@@6B@				; VidView::`vftable'
PUBLIC	??_GVidView@@UAEPAXI@Z				; VidView::`scalar deleting destructor'
PUBLIC	??_EVidView@@UAEPAXI@Z				; VidView::`vector deleting destructor'
;	COMDAT ??_7VidView@@6B@
; File D:\Games\duke_nukem_forever\Hacked\MeshEd\vid_main.h
CONST	SEGMENT
??_7VidView@@6B@ DD FLAT:??_EVidView@@UAEPAXI@Z		; VidView::`vftable'
CONST	ENDS
;	COMDAT ??0VidView@@QAE@KKK@Z
_TEXT	SEGMENT
_Width$ = 8
_Height$ = 12
_Bpp$ = 16
_this$ = -4
??0VidView@@QAE@KKK@Z PROC NEAR				; VidView::VidView, COMDAT

; 184  : 	VidView(U32 Width,U32 Height,U32 Bpp) : width(Width),height(Height),bpp(Bpp) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Width$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Height$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Bpp$[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7VidView@@6B@ ; VidView::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0VidView@@QAE@KKK@Z ENDP				; VidView::VidView
_TEXT	ENDS
PUBLIC	??1VidView@@UAE@XZ				; VidView::~VidView
;	COMDAT ??_GVidView@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GVidView@@UAEPAXI@Z PROC NEAR			; VidView::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VidView@@UAE@XZ			; VidView::~VidView
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L57058
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L57058:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVidView@@UAEPAXI@Z ENDP				; VidView::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??1VidView@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1VidView@@UAE@XZ PROC NEAR				; VidView::~VidView, COMDAT

; 185  : 	virtual ~VidView(void){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7VidView@@6B@ ; VidView::`vftable'
	mov	esp, ebp
	pop	ebp
	ret	0
??1VidView@@UAE@XZ ENDP					; VidView::~VidView
_TEXT	ENDS
PUBLIC	??1ViewD3D@@UAE@XZ				; ViewD3D::~ViewD3D
;	COMDAT ??_GViewD3D@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GViewD3D@@UAEPAXI@Z PROC NEAR			; ViewD3D::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ViewD3D@@UAE@XZ			; ViewD3D::~ViewD3D
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L65211
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L65211:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GViewD3D@@UAEPAXI@Z ENDP				; ViewD3D::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??1ViewD3D@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1ViewD3D@@UAE@XZ PROC NEAR				; ViewD3D::~ViewD3D, COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VidView@@UAE@XZ			; VidView::~VidView
	mov	esp, ebp
	pop	ebp
	ret	0
??1ViewD3D@@UAE@XZ ENDP					; ViewD3D::~ViewD3D
_TEXT	ENDS
PUBLIC	?Swap@VidD3D@@UAEKK@Z				; VidD3D::Swap
_TEXT	SEGMENT
_this$ = -4
?Swap@VidD3D@@UAEKK@Z PROC NEAR				; VidD3D::Swap

; 25   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 	dev->Present(null,null,null,null);

	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+60]

; 27   : 	return TRUE;

	mov	eax, 1

; 28   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Swap@VidD3D@@UAEKK@Z ENDP				; VidD3D::Swap
_TEXT	ENDS
PUBLIC	?ClearScreen@VidD3D@@UAEXK@Z			; VidD3D::ClearScreen
EXTRN	?DXTraceA@@YGJPADKJ0H@Z:NEAR			; DXTraceA
EXTRN	__imp_@xxx_fatal@4:NEAR
EXTRN	__fltused:NEAR
_DATA	SEGMENT
$SG65229 DB	'VidD3D::ClearScreen: failed', 00H
$SG65230 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65231 DB	'VidD3D::ClearScreen: failed', 00H
_DATA	ENDS
_TEXT	SEGMENT
_color$ = 8
_this$ = -28
_ret$ = -24
_rect$ = -16
_clear_far$ = -20
?ClearScreen@VidD3D@@UAEXK@Z PROC NEAR			; VidD3D::ClearScreen

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	U32 ret;
; 33   : 
; 34   : 	D3DRECT rect;
; 35   : 
; 36   : 	rect.x1=vid_state.clip_x;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+16]
	mov	DWORD PTR _rect$[ebp], ecx

; 37   : 	rect.y1=vid_state.clip_y;

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+18]
	mov	DWORD PTR _rect$[ebp+4], eax

; 38   : 	rect.x2=rect.x1 + vid_state.clip_width;

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	mov	eax, DWORD PTR _rect$[ebp]
	add	eax, edx
	mov	DWORD PTR _rect$[ebp+8], eax

; 39   : 	rect.y2=rect.y1 + vid_state.clip_height;

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+22]
	mov	eax, DWORD PTR _rect$[ebp+4]
	add	eax, edx
	mov	DWORD PTR _rect$[ebp+12], eax

; 40   : 
; 41   : 	float clear_far=1.0f;

	mov	DWORD PTR _clear_far$[ebp], 1065353216	; 3f800000H

; 42   : #if 0
; 43   : 	if (!vid_state.support_wbuffer)
; 44   : 		clear_far=1.0f;
; 45   : #endif
; 46   : 
; 47   : 	if (vid_state.has_stencil)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	je	SHORT $L65225

; 49   : 		ret=dev->Clear(1,&rect,
; 50   : 					   D3DCLEAR_STENCIL|D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
; 51   : 					   color,clear_far,0);

	push	0
	mov	eax, DWORD PTR _clear_far$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	push	7
	lea	edx, DWORD PTR _rect$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+144]
	mov	DWORD PTR _ret$[ebp], eax

; 53   : 	else

	jmp	SHORT $L65226
$L65225:

; 55   : 		ret=dev->Clear(1,&rect,
; 56   : 					   D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
; 57   : 					   color,clear_far,0);

	push	0
	mov	eax, DWORD PTR _clear_far$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	push	3
	lea	edx, DWORD PTR _rect$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+144]
	mov	DWORD PTR _ret$[ebp], eax
$L65226:

; 65   : 	if (ret!=D3D_OK) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $L65228

; 66   : 		DXTrace(__FILE__,__LINE__, ret, "VidD3D::ClearScreen: failed", TRUE);

	push	1
	push	OFFSET FLAT:$SG65229
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	push	66					; 00000042H
	push	OFFSET FLAT:$SG65230
	call	?DXTraceA@@YGJPADKJ0H@Z			; DXTraceA

; 67   : 		xxx_fatal("VidD3D::ClearScreen: failed");

	mov	ecx, OFFSET FLAT:$SG65231
	call	DWORD PTR __imp_@xxx_fatal@4
$L65228:

; 69   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ClearScreen@VidD3D@@UAEXK@Z ENDP			; VidD3D::ClearScreen
_TEXT	ENDS
PUBLIC	?ClipWindow@VidD3D@@UAEXKKKK@Z			; VidD3D::ClipWindow
PUBLIC	?_d_assert@@YAXPBDK@Z				; _d_assert
EXTRN	?_deb_clip_x@@3MA:DWORD				; _deb_clip_x
EXTRN	?_deb_clip_y@@3MA:DWORD				; _deb_clip_y
EXTRN	?_deb_clip_width@@3MA:DWORD			; _deb_clip_width
EXTRN	?_deb_clip_height@@3MA:DWORD			; _deb_clip_height
EXTRN	?flush@VManager@@QAEXXZ:NEAR			; VManager::flush
_DATA	SEGMENT
$SG65244 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65259 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_x$ = 8
_y$ = 12
_x2$ = 16
_y2$ = 20
_this$ = -28
_viewport$ = -24
?ClipWindow@VidD3D@@UAEXKKKK@Z PROC NEAR		; VidD3D::ClipWindow

; 72   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx
$L65239:

; 73   : 	D_ASSERT(dev);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L65242
	push	73					; 00000049H
	push	OFFSET FLAT:$SG65244
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65242:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65239

; 74   : 
; 75   : 	D3DVIEWPORT8 viewport;
; 76   : 
; 77   : 	if ((I32)x<0)

	cmp	DWORD PTR _x$[ebp], 0
	jge	SHORT $L65247

; 78   : 		x=0;

	mov	DWORD PTR _x$[ebp], 0
$L65247:

; 79   : 	if ((I32)y<0)

	cmp	DWORD PTR _y$[ebp], 0
	jge	SHORT $L65249

; 80   : 		y=0;

	mov	DWORD PTR _y$[ebp], 0
$L65249:

; 81   : 	if (x2>res.width)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x2$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jbe	SHORT $L65250

; 82   : 		x2=res.width;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _x2$[ebp], edx
$L65250:

; 83   : 	if (y2>res.height)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y2$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jbe	SHORT $L65251

; 84   : 		y2=res.height;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _y2$[ebp], eax
$L65251:

; 85   : 
; 86   : 	D_ASSERT((((I32)y2) - ((I32)y))>=0);

	mov	ecx, DWORD PTR _y2$[ebp]
	sub	ecx, DWORD PTR _y$[ebp]
	test	ecx, ecx
	jge	SHORT $L65257
	push	86					; 00000056H
	push	OFFSET FLAT:$SG65259
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65257:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L65251

; 87   : 
; 88   : 	viewport.X=x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _viewport$[ebp], eax

; 89   : 	viewport.Y=y;

	mov	ecx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _viewport$[ebp+4], ecx

; 90   : 	viewport.Width=x2 - x;

	mov	edx, DWORD PTR _x2$[ebp]
	sub	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _viewport$[ebp+8], edx

; 91   : 	viewport.Height=y2 -y;

	mov	eax, DWORD PTR _y2$[ebp]
	sub	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _viewport$[ebp+12], eax

; 92   : 	viewport.MinZ=0.0;

	mov	DWORD PTR _viewport$[ebp+16], 0

; 93   : 	viewport.MaxZ=1.0f;

	mov	DWORD PTR _viewport$[ebp+20], 1065353216 ; 3f800000H

; 94   : 
; 95   : 	vbuffers->flush();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 96   : 
; 97   : 	dev->SetViewport(&viewport);

	lea	edx, DWORD PTR _viewport$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+160]

; 98   : 
; 99   : 	vid_state.clip_x=(U16)x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR [eax+16], cx

; 100  : 	vid_state.clip_width=(U16)(x2 - x);

	mov	edx, DWORD PTR _x2$[ebp]
	sub	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+20], dx

; 101  : 	vid_state.clip_y=(U16)y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _y$[ebp]
	mov	WORD PTR [ecx+18], dx

; 102  : 	vid_state.clip_height=(U16)(y2 - y);

	mov	eax, DWORD PTR _y2$[ebp]
	sub	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+22], ax

; 103  : 
; 104  : 	_deb_clip_x=(float)vid_state.clip_x;

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+16]
	mov	DWORD PTR -32+[ebp], eax
	fild	DWORD PTR -32+[ebp]
	fstp	DWORD PTR ?_deb_clip_x@@3MA		; _deb_clip_x

; 105  : 	_deb_clip_y=(float)vid_state.clip_y;

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+18]
	mov	DWORD PTR -36+[ebp], edx
	fild	DWORD PTR -36+[ebp]
	fstp	DWORD PTR ?_deb_clip_y@@3MA		; _deb_clip_y

; 106  : 	_deb_clip_width=(float)vid_state.clip_width;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+20]
	mov	DWORD PTR -40+[ebp], ecx
	fild	DWORD PTR -40+[ebp]
	fstp	DWORD PTR ?_deb_clip_width@@3MA		; _deb_clip_width

; 107  : 	_deb_clip_height=(float)vid_state.clip_height;

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+22]
	mov	DWORD PTR -44+[ebp], eax
	fild	DWORD PTR -44+[ebp]
	fstp	DWORD PTR ?_deb_clip_height@@3MA	; _deb_clip_height

; 108  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ClipWindow@VidD3D@@UAEXKKKK@Z ENDP			; VidD3D::ClipWindow
_TEXT	ENDS
EXTRN	__imp_?_global@@3PAVXGlobal@@A:DWORD
EXTRN	__imp_?assert@XGlobal@@QAEXPBDK@Z:NEAR
;	COMDAT ?_d_assert@@YAXPBDK@Z
_TEXT	SEGMENT
_file$ = 8
_line$ = 12
?_d_assert@@YAXPBDK@Z PROC NEAR				; _d_assert, COMDAT

; 1483 : {

	push	ebp
	mov	ebp, esp

; 1484 : 	_global->assert(file,line);

	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp_?_global@@3PAVXGlobal@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?assert@XGlobal@@QAEXPBDK@Z

; 1485 : }

	pop	ebp
	ret	0
?_d_assert@@YAXPBDK@Z ENDP				; _d_assert
_TEXT	ENDS
PUBLIC	?SetClipBounds@VidD3D@@UAEXKKKK@Z		; VidD3D::SetClipBounds
_TEXT	SEGMENT
_this$ = -4
?SetClipBounds@VidD3D@@UAEXKKKK@Z PROC NEAR		; VidD3D::SetClipBounds

; 111  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 	_deb_clip_x=(float)vid_state.clip_x;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+16]
	mov	DWORD PTR -8+[ebp], ecx
	fild	DWORD PTR -8+[ebp]
	fstp	DWORD PTR ?_deb_clip_x@@3MA		; _deb_clip_x

; 113  : 	_deb_clip_y=(float)vid_state.clip_y;

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+18]
	mov	DWORD PTR -12+[ebp], eax
	fild	DWORD PTR -12+[ebp]
	fstp	DWORD PTR ?_deb_clip_y@@3MA		; _deb_clip_y

; 114  : 	_deb_clip_width=(float)vid_state.clip_width;

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	mov	DWORD PTR -16+[ebp], edx
	fild	DWORD PTR -16+[ebp]
	fstp	DWORD PTR ?_deb_clip_width@@3MA		; _deb_clip_width

; 115  : 	_deb_clip_height=(float)vid_state.clip_height;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+22]
	mov	DWORD PTR -20+[ebp], ecx
	fild	DWORD PTR -20+[ebp]
	fstp	DWORD PTR ?_deb_clip_height@@3MA	; _deb_clip_height

; 116  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetClipBounds@VidD3D@@UAEXKKKK@Z ENDP			; VidD3D::SetClipBounds
_TEXT	ENDS
PUBLIC	?ColorWrite@VidD3D@@UAEXE@Z			; VidD3D::ColorWrite
_DATA	SEGMENT
	ORG $+1
$SG65288 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65294 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_enable$ = 8
_this$ = -4
?ColorWrite@VidD3D@@UAEXE@Z PROC NEAR			; VidD3D::ColorWrite

; 119  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
$L65283:

; 120  : 	D_ASSERT(((enable==0)||(enable==1)));

	mov	eax, DWORD PTR _enable$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L65286
	mov	ecx, DWORD PTR _enable$[ebp]
	and	ecx, 255				; 000000ffH
	cmp	ecx, 1
	je	SHORT $L65286
	push	120					; 00000078H
	push	OFFSET FLAT:$SG65288
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65286:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L65283
$L65285:

; 121  : 	D_ASSERT(dev);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L65292
	push	121					; 00000079H
	push	OFFSET FLAT:$SG65294
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65292:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65285

; 122  : 
; 123  : 	vbuffers->flush();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 124  : 
; 125  : 	if (enable)

	mov	eax, DWORD PTR _enable$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L65295

; 126  : 		dev->SetRenderState(D3DRS_COLORWRITEENABLE,D3DCOLORWRITEENABLE_RED|D3DCOLORWRITEENABLE_GREEN|D3DCOLORWRITEENABLE_BLUE);

	push	7
	push	168					; 000000a8H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+200]

; 127  : 	else

	jmp	SHORT $L65296
$L65295:

; 128  : 		dev->SetRenderState(D3DRS_COLORWRITEENABLE,0);

	push	0
	push	168					; 000000a8H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+200]
$L65296:

; 129  : 
; 130  : 	vid_state.color_write=enable;

	mov	ecx, DWORD PTR _enable$[ebp]
	and	ecx, 255				; 000000ffH
	and	ecx, 1
	shl	ecx, 13					; 0000000dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	ah, -33					; ffffffdfH
	or	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 131  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ColorWrite@VidD3D@@UAEXE@Z ENDP			; VidD3D::ColorWrite
_TEXT	ENDS
PUBLIC	?DepthWrite@VidD3D@@UAEXE@Z			; VidD3D::DepthWrite
_DATA	SEGMENT
	ORG $+1
$SG65306 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65312 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_enable$ = 8
_this$ = -4
?DepthWrite@VidD3D@@UAEXE@Z PROC NEAR			; VidD3D::DepthWrite

; 134  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
$L65301:

; 135  : 	D_ASSERT(((enable==0)||(enable==1)));

	mov	eax, DWORD PTR _enable$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L65304
	mov	ecx, DWORD PTR _enable$[ebp]
	and	ecx, 255				; 000000ffH
	cmp	ecx, 1
	je	SHORT $L65304
	push	135					; 00000087H
	push	OFFSET FLAT:$SG65306
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65304:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L65301
$L65303:

; 136  : 	D_ASSERT(dev);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L65310
	push	136					; 00000088H
	push	OFFSET FLAT:$SG65312
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65310:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65303

; 137  : 
; 138  : 	vbuffers->flush();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 139  : 
; 140  : 	dev->SetRenderState(D3DRS_ZWRITEENABLE,enable);

	mov	eax, DWORD PTR _enable$[ebp]
	and	eax, 255				; 000000ffH
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+200]

; 141  : 	vid_state.depth_write=enable;

	mov	ecx, DWORD PTR _enable$[ebp]
	and	ecx, 255				; 000000ffH
	and	ecx, 1
	shl	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	ah, -17					; ffffffefH
	or	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 142  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DepthWrite@VidD3D@@UAEXE@Z ENDP			; VidD3D::DepthWrite
_TEXT	ENDS
PUBLIC	?FlatColor@VidD3D@@UAEXEEE@Z			; VidD3D::FlatColor
_TEXT	SEGMENT
_r$ = 8
_g$ = 12
_b$ = 16
_this$ = -4
?FlatColor@VidD3D@@UAEXEEE@Z PROC NEAR			; VidD3D::FlatColor

; 145  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 	vid_state.color_r=r;

	mov	eax, DWORD PTR _r$[ebp]
	and	eax, 255				; 000000ffH
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	dl, 0
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 147  : 	vid_state.color_g=g;

	mov	ecx, DWORD PTR _g$[ebp]
	and	ecx, 255				; 000000ffH
	and	ecx, 255				; 000000ffH
	shl	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	ah, 0
	or	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 148  : 	vid_state.color_b=b;

	mov	edx, DWORD PTR _b$[ebp]
	and	edx, 255				; 000000ffH
	and	edx, 255				; 000000ffH
	shl	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, -16711681				; ff00ffffH
	or	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 149  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?FlatColor@VidD3D@@UAEXEEE@Z ENDP			; VidD3D::FlatColor
_TEXT	ENDS
PUBLIC	?FlatAlpha@VidD3D@@UAEXE@Z			; VidD3D::FlatAlpha
_TEXT	SEGMENT
_a$ = 8
_this$ = -4
?FlatAlpha@VidD3D@@UAEXE@Z PROC NEAR			; VidD3D::FlatAlpha

; 152  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 	vid_state.color_a=a;

	mov	eax, DWORD PTR _a$[ebp]
	and	eax, 255				; 000000ffH
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 16777215				; 00ffffffH
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FlatAlpha@VidD3D@@UAEXE@Z ENDP				; VidD3D::FlatAlpha
_TEXT	ENDS
PUBLIC	?AlphaTestValue@VidD3D@@UAEEE@Z			; VidD3D::AlphaTestValue
_DATA	SEGMENT
	ORG $+1
$SG65332 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_a$ = 8
_this$ = -8
_ret$ = -4
?AlphaTestValue@VidD3D@@UAEEE@Z PROC NEAR		; VidD3D::AlphaTestValue

; 157  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
$L65327:

; 158  : 	D_ASSERT(dev);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L65330
	push	158					; 0000009eH
	push	OFFSET FLAT:$SG65332
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65330:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65327

; 159  : 	
; 160  : 	vbuffers->flush();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 161  : 
; 162  : 	U8 ret=vid_state.alpha_test_val;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _ret$[ebp], cl

; 163  : 	vid_state.alpha_test_val=a;

	mov	edx, DWORD PTR _a$[ebp]
	and	edx, 255				; 000000ffH
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	cl, 0
	or	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 164  : 	dev->SetRenderState(D3DRS_ALPHAREF,a);

	mov	eax, DWORD PTR _a$[ebp]
	and	eax, 255				; 000000ffH
	push	eax
	push	24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+200]

; 165  : 
; 166  : 	return ret;

	mov	al, BYTE PTR _ret$[ebp]

; 167  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AlphaTestValue@VidD3D@@UAEEE@Z ENDP			; VidD3D::AlphaTestValue
_TEXT	ENDS
PUBLIC	?ColorMode@VidD3D@@UAE?AW4vidcolormodetype_t@@W42@@Z ; VidD3D::ColorMode
_DATA	SEGMENT
	ORG $+1
$SG65343 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65356 DB	'VidD3D::ColorMode: bogus type', 00H
	ORG $+2
$SG65359 DB	'Texture stage failure', 00H
	ORG $+2
$SG65362 DB	'Texture stage failure', 00H
	ORG $+2
$SG65365 DB	'Texture stage failure', 00H
_DATA	ENDS
_TEXT	SEGMENT
_vcmtype$ = 8
_this$ = -8
_ret$ = -4
?ColorMode@VidD3D@@UAE?AW4vidcolormodetype_t@@W42@@Z PROC NEAR ; VidD3D::ColorMode

; 170  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
$L65338:

; 171  : 	D_ASSERT(dev);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L65341
	push	171					; 000000abH
	push	OFFSET FLAT:$SG65343
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65341:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65338

; 172  : 
; 173  : 	vidcolormodetype_t ret=(vidcolormodetype_t)vid_state.color_mode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 14					; 0000000eH
	and	eax, 7
	mov	DWORD PTR _ret$[ebp], eax

; 174  : 
; 175  : #if 0
; 176  : 	if (vcmtype==ret)
; 177  : 		return ret;
; 178  : #endif
; 179  : 
; 180  : 	vbuffers->flush();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 183  : 	{

	mov	edx, DWORD PTR _vcmtype$[ebp]
	mov	DWORD PTR -12+[ebp], edx
	cmp	DWORD PTR -12+[ebp], 4
	ja	$L65355
	mov	eax, DWORD PTR -12+[ebp]
	jmp	DWORD PTR $L66565[eax*4]
$L65350:

; 184  : 		case VCM_FLAT:
; 185  : 			d3d_state.color_op0=D3DTOP_SELECTARG1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	dh, -32					; ffffffe0H
	or	dh, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 186  : 			d3d_state.color1_arg0=D3DTA_DIFFUSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+64], 0

; 187  : 			d3d_state.color2_arg0=D3DTA_DIFFUSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+65], 0

; 188  : 			vid_state.flat_shade=TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	or	ecx, 8388608				; 00800000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 189  : 			break;

	jmp	$L65347
$L65351:

; 190  : 		case VCM_GOURAUD:
; 191  : 			d3d_state.color_op0=D3DTOP_SELECTARG1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	and	ch, -32					; ffffffe0H
	or	ch, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], ecx

; 192  : 			d3d_state.color1_arg0=D3DTA_DIFFUSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+64], 0

; 193  : 			d3d_state.color2_arg0=D3DTA_DIFFUSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+65], 0

; 194  : 			vid_state.flat_shade=FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -8388609				; ff7fffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 195  : 			break;

	jmp	$L65347
$L65352:

; 196  : 		case VCM_TEXTURE:
; 197  : 			d3d_state.color_op0=D3DTOP_SELECTARG2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	and	ah, -32					; ffffffe0H
	or	ah, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 198  : 			d3d_state.color1_arg0=D3DTA_DIFFUSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+64], 0

; 199  : 			d3d_state.color2_arg0=D3DTA_TEXTURE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+65], 2

; 200  : 			break;

	jmp	SHORT $L65347
$L65353:

; 201  : 		case VCM_FLATTEXTURE:
; 202  : 			d3d_state.color_op0=D3DTOP_MODULATE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	dh, -32					; ffffffe0H
	or	dh, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 203  : 			d3d_state.color1_arg0=D3DTA_DIFFUSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+64], 0

; 204  : 			d3d_state.color2_arg0=D3DTA_TEXTURE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+65], 2

; 205  : 			vid_state.flat_shade=TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	or	ecx, 8388608				; 00800000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 206  : 			break;

	jmp	SHORT $L65347
$L65354:

; 207  : 		case VCM_GOURAUDTEXTURE:
; 208  : 			d3d_state.color_op0=D3DTOP_MODULATE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	and	ch, -32					; ffffffe0H
	or	ch, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], ecx

; 209  : 			d3d_state.color1_arg0=D3DTA_DIFFUSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+64], 0

; 210  : 			d3d_state.color2_arg0=D3DTA_TEXTURE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+65], 2

; 211  : 			vid_state.flat_shade=FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -8388609				; ff7fffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 212  : 			break;

	jmp	SHORT $L65347
$L65355:

; 213  : 		default:
; 214  : 			xxx_fatal("VidD3D::ColorMode: bogus type");

	mov	ecx, OFFSET FLAT:$SG65356
	call	DWORD PTR __imp_@xxx_fatal@4
$L65347:

; 217  : 	
; 218  : 	if (dev->SetTextureStageState(0,D3DTSS_COLOROP,d3d_state.color_op0)!=D3D_OK)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	shr	eax, 8
	and	eax, 31					; 0000001fH
	push	eax
	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+252]
	test	eax, eax
	je	SHORT $L65358

; 219  : 		xxx_fatal("Texture stage failure");

	mov	ecx, OFFSET FLAT:$SG65359
	call	DWORD PTR __imp_@xxx_fatal@4
$L65358:

; 220  : 	if (dev->SetTextureStageState(0,D3DTSS_COLORARG1,d3d_state.color1_arg0)!=D3D_OK)

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+64]
	push	edx
	push	2
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+252]
	test	eax, eax
	je	SHORT $L65361

; 221  : 		xxx_fatal("Texture stage failure");

	mov	ecx, OFFSET FLAT:$SG65362
	call	DWORD PTR __imp_@xxx_fatal@4
$L65361:

; 222  : 	if (dev->SetTextureStageState(0,D3DTSS_COLORARG2,d3d_state.color2_arg0)!=D3D_OK)

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+65]
	push	ecx
	push	3
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR [edx]
	push	eax
	call	DWORD PTR [ecx+252]
	test	eax, eax
	je	SHORT $L65364

; 223  : 		xxx_fatal("Texture stage failure");

	mov	ecx, OFFSET FLAT:$SG65365
	call	DWORD PTR __imp_@xxx_fatal@4
$L65364:

; 224  : 
; 225  : 	vid_state.color_mode=vcmtype;

	mov	edx, DWORD PTR _vcmtype$[ebp]
	and	edx, 7
	shl	edx, 14					; 0000000eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -114689				; fffe3fffH
	or	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 226  : 	
; 227  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 228  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$L66565:
	DD	$L65350
	DD	$L65351
	DD	$L65352
	DD	$L65353
	DD	$L65354
?ColorMode@VidD3D@@UAE?AW4vidcolormodetype_t@@W42@@Z ENDP ; VidD3D::ColorMode
_TEXT	ENDS
PUBLIC	?AlphaMode@VidD3D@@UAE?AW4vidalphamodetype_t@@W42@@Z ; VidD3D::AlphaMode
_DATA	SEGMENT
	ORG $+2
$SG65375 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65387 DB	'VidD3D::AlphaMode: bogus type', 00H
_DATA	ENDS
_TEXT	SEGMENT
_vamtype$ = 8
_this$ = -8
_ret$ = -4
?AlphaMode@VidD3D@@UAE?AW4vidalphamodetype_t@@W42@@Z PROC NEAR ; VidD3D::AlphaMode

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
$L65370:

; 232  : 	D_ASSERT(dev);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L65373
	push	232					; 000000e8H
	push	OFFSET FLAT:$SG65375
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65373:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65370

; 233  : 	
; 234  : 	vidalphamodetype_t ret=(vidalphamodetype_t)vid_state.alpha_mode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 17					; 00000011H
	and	eax, 7
	mov	DWORD PTR _ret$[ebp], eax

; 235  : 
; 236  : #if 0
; 237  : 	if (vamtype==ret)
; 238  : 		return ret;
; 239  : #endif
; 240  : 	
; 241  : 	vbuffers->flush();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 244  : 	{

	mov	edx, DWORD PTR _vamtype$[ebp]
	mov	DWORD PTR -12+[ebp], edx
	cmp	DWORD PTR -12+[ebp], 3
	ja	$L65386
	mov	eax, DWORD PTR -12+[ebp]
	jmp	DWORD PTR $L66567[eax*4]
$L65382:

; 245  : 		case VAM_FLAT:
; 246  : 			d3d_state.alpha_op0=D3DTOP_SELECTARG1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	edx, -260046849				; f07fffffH
	or	edx, 16777216				; 01000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 247  : 			d3d_state.alpha1_arg0=D3DTA_DIFFUSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+66], 0

; 248  : 			d3d_state.alpha2_arg0=D3DTA_DIFFUSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+67], 0

; 249  : 			vid_state.flat_alpha=TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	or	ecx, 16777216				; 01000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 250  : 			break;

	jmp	$L65379
$L65383:

; 251  : 		case VAM_GOURAUD:
; 252  : 			d3d_state.alpha_op0=D3DTOP_SELECTARG1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	and	ecx, -260046849				; f07fffffH
	or	ecx, 16777216				; 01000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], ecx

; 253  : 			d3d_state.alpha1_arg0=D3DTA_DIFFUSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+66], 0

; 254  : 			d3d_state.alpha2_arg0=D3DTA_DIFFUSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+67], 0

; 255  : 			vid_state.flat_alpha=FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -16777217				; feffffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 256  : 			break;

	jmp	SHORT $L65379
$L65384:

; 257  : 		case VAM_TEXTURE:
; 258  : 			d3d_state.alpha_op0=D3DTOP_SELECTARG2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	and	eax, -260046849				; f07fffffH
	or	eax, 25165824				; 01800000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 259  : 			d3d_state.alpha1_arg0=D3DTA_DIFFUSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+66], 0

; 260  : 			d3d_state.alpha2_arg0=D3DTA_TEXTURE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+67], 2

; 261  : 			break;

	jmp	SHORT $L65379
$L65385:

; 262  : 		case VAM_MODULATE_TEXTURE:
; 263  : 			d3d_state.alpha_op0=D3DTOP_MODULATE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	edx, -260046849				; f07fffffH
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 264  : 			d3d_state.alpha1_arg0=D3DTA_DIFFUSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+66], 0

; 265  : 			d3d_state.alpha2_arg0=D3DTA_TEXTURE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+67], 2

; 266  : 			vid_state.flat_alpha=FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -16777217				; feffffffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 267  : 			break;

	jmp	SHORT $L65379
$L65386:

; 268  : 		default:
; 269  : 			xxx_fatal("VidD3D::AlphaMode: bogus type");

	mov	ecx, OFFSET FLAT:$SG65387
	call	DWORD PTR __imp_@xxx_fatal@4
$L65379:

; 272  : 
; 273  : 	vid_state.alpha_mode=vamtype;

	mov	eax, DWORD PTR _vamtype$[ebp]
	and	eax, 7
	shl	eax, 17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -917505				; fff1ffffH
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 274  : 	dev->SetTextureStageState(0,D3DTSS_ALPHAOP,d3d_state.alpha_op0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	push	edx
	push	4
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+252]

; 275  : 	dev->SetTextureStageState(0,D3DTSS_ALPHAARG1,d3d_state.alpha1_arg0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+66]
	push	ecx
	push	5
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR [edx]
	push	eax
	call	DWORD PTR [ecx+252]

; 276  : 	dev->SetTextureStageState(0,D3DTSS_ALPHAARG2,d3d_state.alpha2_arg0);

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+67]
	push	eax
	push	6
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+252]

; 277  : 
; 278  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 279  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$L66567:
	DD	$L65382
	DD	$L65383
	DD	$L65384
	DD	$L65385
?AlphaMode@VidD3D@@UAE?AW4vidalphamodetype_t@@W42@@Z ENDP ; VidD3D::AlphaMode
_TEXT	ENDS
PUBLIC	?BlendMode@VidD3D@@UAE?AW4vidblendmodetype_t@@W42@@Z ; VidD3D::BlendMode
_DATA	SEGMENT
	ORG $+2
$SG65397 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65410 DB	'VidD3D::BlendMode: bogus type', 00H
_DATA	ENDS
_TEXT	SEGMENT
_vbmtype$ = 8
_this$ = -8
_ret$ = -4
?BlendMode@VidD3D@@UAE?AW4vidblendmodetype_t@@W42@@Z PROC NEAR ; VidD3D::BlendMode

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
$L65392:

; 283  : 	D_ASSERT(dev);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L65395
	push	283					; 0000011bH
	push	OFFSET FLAT:$SG65397
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65395:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65392

; 284  : 
; 285  : 	vidblendmodetype_t ret=(vidblendmodetype_t)vid_state.blend_mode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 20					; 00000014H
	and	eax, 7
	mov	DWORD PTR _ret$[ebp], eax

; 286  : 
; 287  : #if 0
; 288  : 	if (vbmtype==ret)
; 289  : 		return ret;
; 290  : #endif
; 291  : 
; 292  : 	vbuffers->flush();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 295  : 	{

	mov	edx, DWORD PTR _vbmtype$[ebp]
	mov	DWORD PTR -12+[ebp], edx
	cmp	DWORD PTR -12+[ebp], 4
	ja	$L65409
	mov	eax, DWORD PTR -12+[ebp]
	jmp	DWORD PTR $L66569[eax*4]
$L65404:

; 296  : 		case VBM_OPAQUE:
; 297  : 			d3d_state.src_blend=D3DBLEND_ONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	edx, -16				; fffffff0H
	or	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 298  : 			d3d_state.dst_blend=D3DBLEND_ZERO;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	dl, 15					; 0000000fH
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 299  : 			break;

	jmp	$L65401
$L65405:

; 300  : 		case VBM_OPAQUETOTAL:
; 301  : 			d3d_state.src_blend=D3DBLEND_ONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	edx, -16				; fffffff0H
	or	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 302  : 			d3d_state.dst_blend=D3DBLEND_ONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	dl, 15					; 0000000fH
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 303  : 			break;

	jmp	SHORT $L65401
$L65406:

; 304  : 		case VBM_TRANS:
; 305  : 			d3d_state.src_blend=D3DBLEND_SRCALPHA;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	edx, -16				; fffffff0H
	or	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 306  : 			d3d_state.dst_blend=D3DBLEND_ZERO;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	dl, 15					; 0000000fH
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 307  : 			break;

	jmp	SHORT $L65401
$L65407:

; 308  : 		case VBM_TRANSTOTAL:
; 309  : 			d3d_state.src_blend=D3DBLEND_SRCALPHA;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	edx, -16				; fffffff0H
	or	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 310  : 			d3d_state.dst_blend=D3DBLEND_ONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	dl, 15					; 0000000fH
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 311  : 			break;

	jmp	SHORT $L65401
$L65408:

; 312  : 		case VBM_TRANSMERGE:
; 313  : 			d3d_state.src_blend=D3DBLEND_SRCALPHA;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	edx, -16				; fffffff0H
	or	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 314  : 			d3d_state.dst_blend=D3DBLEND_INVSRCALPHA;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	dl, 15					; 0000000fH
	or	edx, 96					; 00000060H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], edx

; 315  : 			break;

	jmp	SHORT $L65401
$L65409:

; 316  : 		default:
; 317  : 			xxx_fatal("VidD3D::BlendMode: bogus type");

	mov	ecx, OFFSET FLAT:$SG65410
	call	DWORD PTR __imp_@xxx_fatal@4
$L65401:

; 320  : 
; 321  : 	dev->SetRenderState(D3DRS_SRCBLEND,d3d_state.src_blend);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	and	edx, 15					; 0000000fH
	push	edx
	push	19					; 00000013H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+200]

; 322  : 	dev->SetRenderState(D3DRS_DESTBLEND,d3d_state.dst_blend);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	shr	ecx, 4
	and	ecx, 15					; 0000000fH
	push	ecx
	push	20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR [edx]
	push	eax
	call	DWORD PTR [ecx+200]

; 323  : 
; 324  : 	vid_state.blend_mode=vbmtype;

	mov	edx, DWORD PTR _vbmtype$[ebp]
	and	edx, 7
	shl	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -7340033				; ff8fffffH
	or	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 325  : 
; 326  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 327  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$L66569:
	DD	$L65404
	DD	$L65405
	DD	$L65406
	DD	$L65407
	DD	$L65408
?BlendMode@VidD3D@@UAE?AW4vidblendmodetype_t@@W42@@Z ENDP ; VidD3D::BlendMode
_TEXT	ENDS
PUBLIC	?WindingMode@VidD3D@@UAE?AW4vidwindingmodetype_t@@W42@@Z ; VidD3D::WindingMode
_DATA	SEGMENT
	ORG $+2
$SG65420 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_vwmmode$ = 8
_this$ = -8
_ret$ = -4
?WindingMode@VidD3D@@UAE?AW4vidwindingmodetype_t@@W42@@Z PROC NEAR ; VidD3D::WindingMode

; 330  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
$L65415:

; 331  : 	D_ASSERT(dev);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L65418
	push	331					; 0000014bH
	push	OFFSET FLAT:$SG65420
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65418:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65415

; 332  : 	
; 333  : 	vbuffers->flush();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 334  : 
; 335  : 	vidwindingmodetype_t ret=(vidwindingmodetype_t)vid_state.cull_mode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shr	ecx, 21					; 00000015H
	and	ecx, 3
	mov	DWORD PTR _ret$[ebp], ecx

; 336  : 	dev->SetRenderState(D3DRS_CULLMODE,vwmmode);

	mov	edx, DWORD PTR _vwmmode$[ebp]
	push	edx
	push	22					; 00000016H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+200]

; 337  : 	vid_state.cull_mode=vwmmode;

	mov	eax, DWORD PTR _vwmmode$[ebp]
	and	eax, 3
	shl	eax, 21					; 00000015H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -6291457				; ff9fffffH
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 338  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 339  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?WindingMode@VidD3D@@UAE?AW4vidwindingmodetype_t@@W42@@Z ENDP ; VidD3D::WindingMode
_TEXT	ENDS
PUBLIC	?MinFilterMode@VidD3D@@UAE?AW4vidfiltermodetype_t@@W42@@Z ; VidD3D::MinFilterMode
_DATA	SEGMENT
	ORG $+1
$SG65432 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_vfmmode$ = 8
_this$ = -8
_ret$ = -4
?MinFilterMode@VidD3D@@UAE?AW4vidfiltermodetype_t@@W42@@Z PROC NEAR ; VidD3D::MinFilterMode

; 342  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
$L65427:

; 343  : 	D_ASSERT(dev);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L65430
	push	343					; 00000157H
	push	OFFSET FLAT:$SG65432
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65430:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65427

; 344  : 	
; 345  : 	vbuffers->flush();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 346  : 
; 347  : 	vidfiltermodetype_t ret=(vidfiltermodetype_t)vid_state.min_filter_mode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shr	ecx, 12					; 0000000cH
	and	ecx, 7
	mov	DWORD PTR _ret$[ebp], ecx

; 348  : 	dev->SetTextureStageState(0,D3DTSS_MINFILTER,vfmmode);

	mov	edx, DWORD PTR _vfmmode$[ebp]
	push	edx
	push	17					; 00000011H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+252]

; 349  : 	vid_state.min_filter_mode=vfmmode;

	mov	eax, DWORD PTR _vfmmode$[ebp]
	and	eax, 7
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	dh, -113				; ffffff8fH
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 350  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 351  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MinFilterMode@VidD3D@@UAE?AW4vidfiltermodetype_t@@W42@@Z ENDP ; VidD3D::MinFilterMode
_TEXT	ENDS
PUBLIC	?MagFilterMode@VidD3D@@UAE?AW4vidfiltermodetype_t@@W42@@Z ; VidD3D::MagFilterMode
_DATA	SEGMENT
	ORG $+1
$SG65444 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_vfmmode$ = 8
_this$ = -8
_ret$ = -4
?MagFilterMode@VidD3D@@UAE?AW4vidfiltermodetype_t@@W42@@Z PROC NEAR ; VidD3D::MagFilterMode

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
$L65439:

; 355  : 	D_ASSERT(dev);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L65442
	push	355					; 00000163H
	push	OFFSET FLAT:$SG65444
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65442:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65439

; 356  : 	
; 357  : 	vbuffers->flush();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 358  : 
; 359  : 	vidfiltermodetype_t ret=(vidfiltermodetype_t)vid_state.mag_filter_mode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shr	ecx, 15					; 0000000fH
	and	ecx, 7
	mov	DWORD PTR _ret$[ebp], ecx

; 360  : 	dev->SetTextureStageState(0,D3DTSS_MAGFILTER,vfmmode);

	mov	edx, DWORD PTR _vfmmode$[ebp]
	push	edx
	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+252]

; 361  : 	vid_state.mag_filter_mode=vfmmode;

	mov	eax, DWORD PTR _vfmmode$[ebp]
	and	eax, 7
	shl	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -229377				; fffc7fffH
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 362  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 363  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MagFilterMode@VidD3D@@UAE?AW4vidfiltermodetype_t@@W42@@Z ENDP ; VidD3D::MagFilterMode
_TEXT	ENDS
PUBLIC	?AlphaTestMode@VidD3D@@UAE?AW4vidatestmodetype_t@@W42@@Z ; VidD3D::AlphaTestMode
_DATA	SEGMENT
	ORG $+1
$SG65456 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_vatmode$ = 8
_this$ = -8
_ret$ = -4
?AlphaTestMode@VidD3D@@UAE?AW4vidatestmodetype_t@@W42@@Z PROC NEAR ; VidD3D::AlphaTestMode

; 366  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
$L65451:

; 367  : 	D_ASSERT(dev);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L65454
	push	367					; 0000016fH
	push	OFFSET FLAT:$SG65456
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65454:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65451

; 368  : 	
; 369  : 	vbuffers->flush();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 370  : 
; 371  : 	vidatestmodetype_t ret=(vidatestmodetype_t)vid_state.alpha_test_mode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shr	ecx, 8
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _ret$[ebp], ecx

; 372  : 	dev->SetRenderState(D3DRS_ALPHAFUNC,vatmode);

	mov	edx, DWORD PTR _vatmode$[ebp]
	push	edx
	push	25					; 00000019H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+200]

; 373  : 	vid_state.alpha_test_mode=vatmode;

	mov	eax, DWORD PTR _vatmode$[ebp]
	and	eax, 15					; 0000000fH
	shl	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	dh, -16					; fffffff0H
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 374  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 375  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AlphaTestMode@VidD3D@@UAE?AW4vidatestmodetype_t@@W42@@Z ENDP ; VidD3D::AlphaTestMode
_TEXT	ENDS
PUBLIC	?AlphaTestEnable@VidD3D@@UAEKK@Z		; VidD3D::AlphaTestEnable
_DATA	SEGMENT
	ORG $+1
$SG65468 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_enable$ = 8
_this$ = -8
_ret$ = -4
?AlphaTestEnable@VidD3D@@UAEKK@Z PROC NEAR		; VidD3D::AlphaTestEnable

; 378  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
$L65463:

; 379  : 	D_ASSERT(dev);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L65466
	push	379					; 0000017bH
	push	OFFSET FLAT:$SG65468
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65466:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65463

; 380  : 
; 381  : 	vbuffers->flush();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 382  : 	
; 383  : 	U32 ret=vid_state.alpha_test_enable;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 25					; 00000019H
	and	ecx, 1
	mov	DWORD PTR _ret$[ebp], ecx

; 384  : 	
; 385  : 	vid_state.alpha_test_enable=FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -33554433				; fdffffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 386  : 	if (enable)

	cmp	DWORD PTR _enable$[ebp], 0
	je	SHORT $L65470

; 387  : 		vid_state.alpha_test_enable=TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	or	eax, 33554432				; 02000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
$L65470:

; 388  : 	dev->SetRenderState(D3DRS_ALPHATESTENABLE,vid_state.alpha_test_enable);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 25					; 00000019H
	and	eax, 1
	push	eax
	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+200]

; 389  : 
; 390  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 391  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AlphaTestEnable@VidD3D@@UAEKK@Z ENDP			; VidD3D::AlphaTestEnable
_TEXT	ENDS
PUBLIC	?ForceDraw@VidD3D@@UAEXE@Z			; VidD3D::ForceDraw
_TEXT	SEGMENT
_enable$ = 8
_this$ = -4
?ForceDraw@VidD3D@@UAEXE@Z PROC NEAR			; VidD3D::ForceDraw

; 394  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 395  : 	vid_state.force_draw=FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 396  : 	if (enable)

	mov	eax, DWORD PTR _enable$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L65475

; 397  : 		vid_state.force_draw=TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
$L65475:

; 398  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ForceDraw@VidD3D@@UAEXE@Z ENDP				; VidD3D::ForceDraw
_TEXT	ENDS
PUBLIC	?Antialias@VidD3D@@UAEXE@Z			; VidD3D::Antialias
_TEXT	SEGMENT
_enable$ = 8
_this$ = -4
?Antialias@VidD3D@@UAEXE@Z PROC NEAR			; VidD3D::Antialias

; 401  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	vid_state.antialias=FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 403  : 	if (enable)

	mov	eax, DWORD PTR _enable$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L65480

; 404  : 		vid_state.antialias=TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
$L65480:

; 405  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Antialias@VidD3D@@UAEXE@Z ENDP				; VidD3D::Antialias
_TEXT	ENDS
PUBLIC	?DepthFunc@VidD3D@@UAE?AW4zfunc_modetype_t@@W42@@Z ; VidD3D::DepthFunc
_TEXT	SEGMENT
_zfunc$ = 8
_this$ = -8
_ret$ = -4
?DepthFunc@VidD3D@@UAE?AW4zfunc_modetype_t@@W42@@Z PROC NEAR ; VidD3D::DepthFunc

; 408  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	zfunc_modetype_t ret=(zfunc_modetype_t)vid_state.zfunc;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 8
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _ret$[ebp], ecx

; 410  : 	dev->SetRenderState(D3DRS_ZFUNC,vid_state.zfunc);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 8
	and	eax, 15					; 0000000fH
	push	eax
	push	23					; 00000017H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+200]

; 411  : 	vid_state.zfunc=zfunc;

	mov	ecx, DWORD PTR _zfunc$[ebp]
	and	ecx, 15					; 0000000fH
	shl	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	ah, -16					; fffffff0H
	or	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 412  : 
; 413  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 414  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DepthFunc@VidD3D@@UAE?AW4zfunc_modetype_t@@W42@@Z ENDP	; VidD3D::DepthFunc
_TEXT	ENDS
PUBLIC	?DepthEnable@VidD3D@@UAEXE@Z			; VidD3D::DepthEnable
_DATA	SEGMENT
	ORG $+1
$SG65496 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_enable$ = 8
_this$ = -4
?DepthEnable@VidD3D@@UAEXE@Z PROC NEAR			; VidD3D::DepthEnable

; 417  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
$L65491:

; 418  : 	D_ASSERT(((enable==0)||(enable==1)));

	mov	eax, DWORD PTR _enable$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L65494
	mov	ecx, DWORD PTR _enable$[ebp]
	and	ecx, 255				; 000000ffH
	cmp	ecx, 1
	je	SHORT $L65494
	push	418					; 000001a2H
	push	OFFSET FLAT:$SG65496
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65494:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L65491

; 419  : 
; 420  : #if 0
; 421  : 	if (vid_state.depth_enabled==enable)
; 422  : 		return;
; 423  : #endif
; 424  : 	
; 425  : 	vbuffers->flush();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 426  : 
; 427  : 	vid_state.depth_enabled=TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 428  : 	if (enable)

	mov	ecx, DWORD PTR _enable$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L65497

; 430  : 		if (vid_state.support_wbuffer)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L65498

; 431  : 			dev->SetRenderState(D3DRS_ZENABLE,D3DZB_USEW);

	push	2
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+200]

; 432  : 		else

	jmp	SHORT $L65499
$L65498:

; 433  : 			dev->SetRenderState(D3DRS_ZENABLE,D3DZB_TRUE);

	push	1
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+200]
$L65499:

; 434  : 		dev->SetRenderState(D3DRS_ZFUNC,vid_state.zfunc);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 8
	and	edx, 15					; 0000000fH
	push	edx
	push	23					; 00000017H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+200]

; 436  : 	else

	jmp	SHORT $L65500
$L65497:

; 438  : 		dev->SetRenderState(D3DRS_ZFUNC,D3DCMP_ALWAYS);

	push	8
	push	23					; 00000017H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+200]

; 439  : 		dev->SetRenderState(D3DRS_ZENABLE,D3DZB_FALSE);

	push	0
	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+200]

; 440  : 		vid_state.depth_enabled=FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	cl, 127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$L65500:

; 442  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DepthEnable@VidD3D@@UAEXE@Z ENDP			; VidD3D::DepthEnable
_TEXT	ENDS
PUBLIC	?_clip_test_vector@@YAXPAUvector_str@@@Z	; _clip_test_vector
_TEXT	SEGMENT
?_clip_test_vector@@YAXPAUvector_str@@@Z PROC NEAR	; _clip_test_vector

; 448  : 	_asm
; 449  : 	{
; 450  : 		mov		eax,dword ptr[esp+4]

	mov	eax, DWORD PTR [esp+4]

; 451  : 		fld		dword ptr[eax]

	fld	DWORD PTR [eax]

; 452  : 		fld		dword ptr[eax+4]

	fld	DWORD PTR [eax+4]

; 453  : 		fld		dword ptr[eax+8]

	fld	DWORD PTR [eax+8]

; 454  : 		fstp	st(0)

	fstp	ST(0)

; 455  : 		fstp	st(0)

	fstp	ST(0)

; 456  : 		fstp	st(0)

	fstp	ST(0)

; 457  : 		ret

	ret	0
?_clip_test_vector@@YAXPAUvector_str@@@Z ENDP		; _clip_test_vector
_TEXT	ENDS
PUBLIC	?_clip_sanity_vector@@YAXPAUvector_str@@@Z	; _clip_sanity_vector
_TEXT	SEGMENT
?_clip_sanity_vector@@YAXPAUvector_str@@@Z PROC NEAR	; _clip_sanity_vector

; 463  : 	/* just check for bad float's */
; 464  : 	_asm
; 465  : 	{
; 466  : 		mov		eax,dword ptr[esp+4]

	mov	eax, DWORD PTR [esp+4]

; 467  : 		fld		dword ptr[eax]

	fld	DWORD PTR [eax]

; 468  : 		fld		dword ptr[eax+4]

	fld	DWORD PTR [eax+4]

; 469  : 		fld		dword ptr[eax+8]

	fld	DWORD PTR [eax+8]

; 470  : 		fstp	st(0)

	fstp	ST(0)

; 471  : 		fstp	st(0)

	fstp	ST(0)

; 472  : 		fstp	st(0)

	fstp	ST(0)

; 473  : 		ret

	ret	0
?_clip_sanity_vector@@YAXPAUvector_str@@@Z ENDP		; _clip_sanity_vector
_TEXT	ENDS
PUBLIC	?match_deb_coords@@YAKPAUDxVertexT@@00@Z	; match_deb_coords
_TEXT	SEGMENT
_v1$ = 8
_v2$ = 12
_v3$ = 16
_v$ = -12
_i$ = -16
_fit$65522 = -20
?match_deb_coords@@YAKPAUDxVertexT@@00@Z PROC NEAR	; match_deb_coords

; 483  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 484  : 	DxVertexT *v[3];
; 485  : 
; 486  : 	v[0]=v1;

	mov	eax, DWORD PTR _v1$[ebp]
	mov	DWORD PTR _v$[ebp], eax

; 487  : 	v[1]=v2;

	mov	ecx, DWORD PTR _v2$[ebp]
	mov	DWORD PTR _v$[ebp+4], ecx

; 488  : 	v[2]=v3;

	mov	edx, DWORD PTR _v3$[ebp]
	mov	DWORD PTR _v$[ebp+8], edx

; 489  : 
; 490  : 	for (U32 i=0;i<3;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65519
$L65520:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L65519:
	cmp	DWORD PTR _i$[ebp], 3
	jae	$L65521

; 492  : 		U32 fit=0;

	mov	DWORD PTR _fit$65522[ebp], 0

; 493  : 		if (v[i]->x >= _deb_x)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _v$[ebp+ecx*4]
	fld	DWORD PTR [edx]
	fcomp	DWORD PTR ?_deb_x@@3MA			; _deb_x
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L65523

; 494  : 			fit++;

	mov	eax, DWORD PTR _fit$65522[ebp]
	add	eax, 1
	mov	DWORD PTR _fit$65522[ebp], eax
$L65523:

; 495  : 		if (v[i]->y >= _deb_y)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _v$[ebp+ecx*4]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR ?_deb_y@@3MA			; _deb_y
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L65524

; 496  : 			fit++;

	mov	eax, DWORD PTR _fit$65522[ebp]
	add	eax, 1
	mov	DWORD PTR _fit$65522[ebp], eax
$L65524:

; 497  : 		if (v[i]->x <= (_deb_x + _deb_width))

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _v$[ebp+ecx*4]
	fld	DWORD PTR ?_deb_x@@3MA			; _deb_x
	fadd	DWORD PTR ?_deb_width@@3MA		; _deb_width
	fcomp	DWORD PTR [edx]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L65525

; 498  : 			fit++;

	mov	eax, DWORD PTR _fit$65522[ebp]
	add	eax, 1
	mov	DWORD PTR _fit$65522[ebp], eax
$L65525:

; 499  : 		if (v[i]->y <= (_deb_y + _deb_height))

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _v$[ebp+ecx*4]
	fld	DWORD PTR ?_deb_y@@3MA			; _deb_y
	fadd	DWORD PTR ?_deb_height@@3MA		; _deb_height
	fcomp	DWORD PTR [edx+4]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L65526

; 500  : 			fit++;

	mov	eax, DWORD PTR _fit$65522[ebp]
	add	eax, 1
	mov	DWORD PTR _fit$65522[ebp], eax
$L65526:

; 501  : 
; 502  : 		if (fit==4)

	cmp	DWORD PTR _fit$65522[ebp], 4
	jne	SHORT $L65527

; 503  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L65516
$L65527:

; 504  : 	}

	jmp	$L65520
$L65521:

; 505  : 
; 506  : 	return FALSE;

	xor	eax, eax
$L65516:

; 507  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?match_deb_coords@@YAKPAUDxVertexT@@00@Z ENDP		; match_deb_coords
_TEXT	ENDS
PUBLIC	?check_clip@VidD3D@@QAEKPAUDxVertexT@@00@Z	; VidD3D::check_clip
_TEXT	SEGMENT
_i$ = -16
_fit$65540 = -20
_v1$ = 8
_v2$ = 12
_v3$ = 16
_this$ = -24
_v$ = -12
?check_clip@VidD3D@@QAEKPAUDxVertexT@@00@Z PROC NEAR	; VidD3D::check_clip

; 510  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 	if (!vid_state.clip_good)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shr	ecx, 23					; 00000017H
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L65534

; 512  : 		return FALSE;

	xor	eax, eax
	jmp	$L65533
$L65534:

; 515  : 
; 516  : 	v[0]=v1;

	mov	edx, DWORD PTR _v1$[ebp]
	mov	DWORD PTR _v$[ebp], edx

; 517  : 	v[1]=v2;

	mov	eax, DWORD PTR _v2$[ebp]
	mov	DWORD PTR _v$[ebp+4], eax

; 518  : 	v[2]=v3;

	mov	ecx, DWORD PTR _v3$[ebp]
	mov	DWORD PTR _v$[ebp+8], ecx

; 519  : 
; 520  : 	for (U32 i=0;i<3;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65537
$L65538:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65537:
	cmp	DWORD PTR _i$[ebp], 3
	jae	$L65539

; 522  : 		U32 fit=0;

	mov	DWORD PTR _fit$65540[ebp], 0

; 523  : 		if (v[i]->x >= _deb_clip_x)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _v$[ebp+eax*4]
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR ?_deb_clip_x@@3MA		; _deb_clip_x
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L65541

; 524  : 			fit++;

	mov	edx, DWORD PTR _fit$65540[ebp]
	add	edx, 1
	mov	DWORD PTR _fit$65540[ebp], edx
$L65541:

; 525  : 		if (v[i]->y >= _deb_clip_y)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _v$[ebp+eax*4]
	fld	DWORD PTR [ecx+4]
	fcomp	DWORD PTR ?_deb_clip_y@@3MA		; _deb_clip_y
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L65542

; 526  : 			fit++;

	mov	edx, DWORD PTR _fit$65540[ebp]
	add	edx, 1
	mov	DWORD PTR _fit$65540[ebp], edx
$L65542:

; 527  : 		if (v[i]->x <= (_deb_clip_x + _deb_clip_width))

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _v$[ebp+eax*4]
	fld	DWORD PTR ?_deb_clip_x@@3MA		; _deb_clip_x
	fadd	DWORD PTR ?_deb_clip_width@@3MA		; _deb_clip_width
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L65543

; 528  : 			fit++;

	mov	edx, DWORD PTR _fit$65540[ebp]
	add	edx, 1
	mov	DWORD PTR _fit$65540[ebp], edx
$L65543:

; 529  : 		if (v[i]->y <= (_deb_clip_y + _deb_clip_height))

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _v$[ebp+eax*4]
	fld	DWORD PTR ?_deb_clip_y@@3MA		; _deb_clip_y
	fadd	DWORD PTR ?_deb_clip_height@@3MA	; _deb_clip_height
	fcomp	DWORD PTR [ecx+4]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L65544

; 530  : 			fit++;

	mov	edx, DWORD PTR _fit$65540[ebp]
	add	edx, 1
	mov	DWORD PTR _fit$65540[ebp], edx
$L65544:

; 531  : 
; 532  : 		if (fit!=4)

	cmp	DWORD PTR _fit$65540[ebp], 4
	je	SHORT $L65545

; 533  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L65533
$L65545:

; 534  : 	}

	jmp	$L65538
$L65539:

; 535  : 
; 536  : 	return FALSE;

	xor	eax, eax
$L65533:

; 537  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?check_clip@VidD3D@@QAEKPAUDxVertexT@@00@Z ENDP		; VidD3D::check_clip
_TEXT	ENDS
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	?rend_begin_debug@VidD3D@@IAEXXZ		; VidD3D::rend_begin_debug
PUBLIC	?rend_end_debug@VidD3D@@IAEXXZ			; VidD3D::rend_end_debug
PUBLIC	?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z	; VidD3D::begin_prim
PUBLIC	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv
PUBLIC	?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z		; VidD3D::end_prim
PUBLIC	?DrawLine@VidD3D@@UAEXPAUvector_str@@000@Z	; VidD3D::DrawLine
EXTRN	__ftol:NEAR
_DATA	SEGMENT
	ORG $+1
$SG65563 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65569 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65589 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
;	COMDAT __real@4@3fff8000000000000000
; File D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.cpp
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
_TEXT	SEGMENT
_p1$ = 8
_p2$ = 12
_c1$ = 16
_c2$ = 20
_this$ = -68
_old_mode$ = -60
_v1$ = -28
_v2$ = -56
_space$65581 = -64
?DrawLine@VidD3D@@UAEXPAUvector_str@@000@Z PROC NEAR	; VidD3D::DrawLine

; 540  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 541  : 	vidcolormodetype_t old_mode;
; 542  : 
; 543  : 	/* don't set state if in primitive batch */
; 544  : 	if (!vid_state.in_prim)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L65555

; 546  : 		REND_POLY_BEGIN();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_begin_debug@VidD3D@@IAEXXZ	; VidD3D::rend_begin_debug

; 547  : 
; 548  : 		old_mode=VCM_GOURAUD;

	mov	DWORD PTR _old_mode$[ebp], 1

; 549  : 		if (vid_state.color_mode!=VCM_GOURAUD)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 14					; 0000000eH
	and	eax, 7
	cmp	eax, 1
	je	SHORT $L65555

; 550  : 			old_mode=ColorMode(VCM_GOURAUD);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+72]
	mov	DWORD PTR _old_mode$[ebp], eax
$L65555:

; 554  : 
; 555  : 	D_ASSERT(p1);D_ASSERT(p2);

	cmp	DWORD PTR _p1$[ebp], 0
	jne	SHORT $L65561
	push	555					; 0000022bH
	push	OFFSET FLAT:$SG65563
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65561:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L65555
$L65560:
	cmp	DWORD PTR _p2$[ebp], 0
	jne	SHORT $L65567
	push	555					; 0000022bH
	push	OFFSET FLAT:$SG65569
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65567:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65560

; 556  : 		
; 557  : 	v1.x=p1->x;v1.y=p1->y;

	mov	edx, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _v1$[ebp], eax
	mov	ecx, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _v1$[ebp+4], edx

; 558  : 	v2.x=p2->x;v2.y=p2->y;

	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _v2$[ebp], ecx
	mov	edx, DWORD PTR _p2$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _v2$[ebp+4], eax

; 559  : 	v1.z=v1.rhw=1.0f;

	mov	DWORD PTR _v1$[ebp+12], 1065353216	; 3f800000H
	mov	ecx, DWORD PTR _v1$[ebp+12]
	mov	DWORD PTR _v1$[ebp+8], ecx

; 560  : 	v2.z=v2.rhw=1.0f;

	mov	DWORD PTR _v2$[ebp+12], 1065353216	; 3f800000H
	mov	edx, DWORD PTR _v2$[ebp+12]
	mov	DWORD PTR _v2$[ebp+8], edx

; 561  : 	if (vid_state.depth_enabled)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 7
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L65570

; 563  : 		v1.z=p1->z;

	mov	edx, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _v1$[ebp+8], eax

; 564  : 		v2.z=p2->z;

	mov	ecx, DWORD PTR _p2$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _v2$[ebp+8], edx

; 565  : 		v1.rhw=1.0f/v1.z;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _v1$[ebp+8]
	fstp	DWORD PTR _v1$[ebp+12]

; 566  : 		v2.rhw=1.0f/v2.z;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _v2$[ebp+8]
	fstp	DWORD PTR _v2$[ebp+12]
$L65570:

; 568  : 	if ((!c1)||(!c2))

	cmp	DWORD PTR _c1$[ebp], 0
	je	SHORT $L65572
	cmp	DWORD PTR _c2$[ebp], 0
	jne	SHORT $L65571
$L65572:

; 570  : 		v1.color=GetColor();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+52]
	mov	DWORD PTR _v1$[ebp+16], eax

; 571  : 		v2.color=v1.color;

	mov	eax, DWORD PTR _v1$[ebp+16]
	mov	DWORD PTR _v2$[ebp+16], eax

; 573  : 	else

	jmp	$L65573
$L65571:

; 575  : 		v1.color=VEC_TO_1RGB(*c1);

	mov	ecx, DWORD PTR _c1$[ebp]
	fld	DWORD PTR [ecx]
	call	__ftol
	mov	esi, eax
	and	esi, 255				; 000000ffH
	shl	esi, 16					; 00000010H
	or	esi, -16777216				; ff000000H
	mov	edx, DWORD PTR _c1$[ebp]
	fld	DWORD PTR [edx+4]
	call	__ftol
	and	eax, 255				; 000000ffH
	shl	eax, 8
	or	esi, eax
	mov	eax, DWORD PTR _c1$[ebp]
	fld	DWORD PTR [eax+8]
	call	__ftol
	and	eax, 255				; 000000ffH
	or	esi, eax
	mov	DWORD PTR _v1$[ebp+16], esi

; 576  : 		v2.color=VEC_TO_1RGB(*c2);

	mov	ecx, DWORD PTR _c2$[ebp]
	fld	DWORD PTR [ecx]
	call	__ftol
	mov	esi, eax
	and	esi, 255				; 000000ffH
	shl	esi, 16					; 00000010H
	or	esi, -16777216				; ff000000H
	mov	edx, DWORD PTR _c2$[ebp]
	fld	DWORD PTR [edx+4]
	call	__ftol
	and	eax, 255				; 000000ffH
	shl	eax, 8
	or	esi, eax
	mov	eax, DWORD PTR _c2$[ebp]
	fld	DWORD PTR [eax+8]
	call	__ftol
	and	eax, 255				; 000000ffH
	or	esi, eax
	mov	DWORD PTR _v2$[ebp+16], esi
$L65573:

; 578  : 
; 579  : 	if (!vid_state.in_prim)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	jne	SHORT $L65580

; 581  : 		DxVertexT *space=begin_prim(PRIM_LINELIST,1*2);

	push	2
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z ; VidD3D::begin_prim
	mov	DWORD PTR _space$65581[ebp], eax

; 582  : 		set_vert_adv(space,&v1);

	lea	eax, DWORD PTR _v1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _space$65581[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 583  : 		set_vert_adv(space,&v2);

	lea	edx, DWORD PTR _v2$[ebp]
	push	edx
	lea	eax, DWORD PTR _space$65581[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 584  : 		end_prim(space,1);

	push	1
	mov	ecx, DWORD PTR _space$65581[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z	; VidD3D::end_prim

; 585  : 		
; 586  : 		if (old_mode!=VCM_GOURAUD)

	cmp	DWORD PTR _old_mode$[ebp], 1
	je	SHORT $L65582

; 587  : 			ColorMode(old_mode);

	mov	edx, DWORD PTR _old_mode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+72]
$L65582:

; 588  : 		REND_POLY_END();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_end_debug@VidD3D@@IAEXXZ		; VidD3D::rend_end_debug

; 590  : 	else

	jmp	$L65590
$L65580:

; 592  : 		set_vert_adv(prim_space,&v1);

	lea	eax, DWORD PTR _v1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 348				; 0000015cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 593  : 		set_vert_adv(prim_space,&v2);

	lea	edx, DWORD PTR _v2$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 348				; 0000015cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 594  : 		prim_count++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], edx
$L65584:

; 595  : 		D_ASSERT(prim_count<=prim_guess);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+344]
	cmp	eax, DWORD PTR [edx+340]
	jbe	SHORT $L65587
	push	595					; 00000253H
	push	OFFSET FLAT:$SG65589
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65587:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65584

; 596  : 		/* see if we need to dump what we have */
; 597  : 		if (prim_count>=prim_guess)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+344]
	cmp	ecx, DWORD PTR [eax+340]
	jb	SHORT $L65590

; 598  : 			EndLines();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+232]
$L65590:

; 600  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DrawLine@VidD3D@@UAEXPAUvector_str@@000@Z ENDP		; VidD3D::DrawLine
_TEXT	ENDS
PUBLIC	?begin_prim@VManager@@QAEPAUDxVertexT@@KK@Z	; VManager::begin_prim
;	COMDAT ?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z
_TEXT	SEGMENT
_type$ = 8
_num_verts$ = 12
_this$ = -8
_space$ = -4
?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z PROC NEAR	; VidD3D::begin_prim, COMDAT

; 437  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 438  : 		DxVertexT *space=vbuffers->begin_prim(type,num_verts);

	mov	eax, DWORD PTR _num_verts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?begin_prim@VManager@@QAEPAUDxVertexT@@KK@Z ; VManager::begin_prim
	mov	DWORD PTR _space$[ebp], eax

; 439  : 		return space;

	mov	eax, DWORD PTR _space$[ebp]

; 440  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z ENDP		; VidD3D::begin_prim
_TEXT	ENDS
PUBLIC	?CheckRoom@VManager@@IAEXG@Z			; VManager::CheckRoom
PUBLIC	??_C@_0BF@HNDD@Already?5in?5primitive?$AA@	; `string'
EXTRN	__imp_@xxx_throw@4:NEAR
;	COMDAT ??_C@_0BF@HNDD@Already?5in?5primitive?$AA@
; File D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidd3d.h
_DATA	SEGMENT
??_C@_0BF@HNDD@Already?5in?5primitive?$AA@ DB 'Already in primitive', 00H ; `string'
_DATA	ENDS
;	COMDAT ?begin_prim@VManager@@QAEPAUDxVertexT@@KK@Z
_TEXT	SEGMENT
_type$ = 8
_num_verts$ = 12
_this$ = -4
?begin_prim@VManager@@QAEPAUDxVertexT@@KK@Z PROC NEAR	; VManager::begin_prim, COMDAT

; 233  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 234  : #ifdef DEBUG
; 235  : 		if (state.in_prim)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L64506

; 236  : 			xxx_throw("Already in primitive");

	mov	ecx, OFFSET FLAT:??_C@_0BF@HNDD@Already?5in?5primitive?$AA@ ; `string'
	call	DWORD PTR __imp_@xxx_throw@4
$L64506:

; 237  : 		state.in_prim=TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	or	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 238  : #endif
; 239  : 		CheckRoom((U16)num_verts);

	mov	dx, WORD PTR _num_verts$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckRoom@VManager@@IAEXG@Z		; VManager::CheckRoom

; 240  : 		cur_prim.start=(U16)vindex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+32]
	mov	WORD PTR [eax+40], dx

; 241  : 		cur_prim.type=(U16)type;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _type$[ebp]
	mov	WORD PTR [eax+36], cx

; 242  : 		return lock_space;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]

; 243  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?begin_prim@VManager@@QAEPAUDxVertexT@@KK@Z ENDP	; VManager::begin_prim
_TEXT	ENDS
PUBLIC	?Lock@VBuffer@@QAEPAXK@Z			; VBuffer::Lock
EXTRN	?MakeRoom@VManager@@IAEXK@Z:NEAR		; VManager::MakeRoom
;	COMDAT ?CheckRoom@VManager@@IAEXG@Z
_TEXT	SEGMENT
_vcount$ = 8
_this$ = -4
?CheckRoom@VManager@@IAEXG@Z PROC NEAR			; VManager::CheckRoom, COMDAT

; 218  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 219  : 		if ((room-=(I16)vcount)<0)

	movsx	eax, WORD PTR _vcount$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jge	SHORT $L64498

; 220  : 			MakeRoom(vcount);

	mov	edx, DWORD PTR _vcount$[ebp]
	and	edx, 65535				; 0000ffffH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeRoom@VManager@@IAEXK@Z		; VManager::MakeRoom
$L64498:

; 221  : 		lock_space=(DxVertexT *)cur->Lock(vcount*28);

	mov	eax, DWORD PTR _vcount$[ebp]
	and	eax, 65535				; 0000ffffH
	imul	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?Lock@VBuffer@@QAEPAXK@Z		; VBuffer::Lock
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], eax

; 222  : 		vindex=cur->vindex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx+32], eax

; 223  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?CheckRoom@VManager@@IAEXG@Z ENDP			; VManager::CheckRoom
_TEXT	ENDS
PUBLIC	??_C@_0BN@CDMH@Unable?5to?5lock?5vertex?5buffer?$AA@ ; `string'
;	COMDAT ??_C@_0BN@CDMH@Unable?5to?5lock?5vertex?5buffer?$AA@
; File D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidd3d.h
_DATA	SEGMENT
??_C@_0BN@CDMH@Unable?5to?5lock?5vertex?5buffer?$AA@ DB 'Unable to lock v'
	DB	'ertex buffer', 00H				; `string'
_DATA	ENDS
;	COMDAT ?Lock@VBuffer@@QAEPAXK@Z
_TEXT	SEGMENT
_lock_size$ = 8
_this$ = -4
?Lock@VBuffer@@QAEPAXK@Z PROC NEAR			; VBuffer::Lock, COMDAT

; 149  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 150  : 		if (state.begin)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 2
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L64381

; 152  : 			if (vbuffer->Lock(cur_off,lock_size,(U8 **)&vcur32,D3DLOCK_DISCARD)!=D3D_OK)

	push	8192					; 00002000H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	eax, DWORD PTR _lock_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+44]
	test	eax, eax
	je	SHORT $L64384

; 153  : 				xxx_fatal("Unable to lock vertex buffer");

	mov	ecx, OFFSET FLAT:??_C@_0BN@CDMH@Unable?5to?5lock?5vertex?5buffer?$AA@ ; `string'
	call	DWORD PTR __imp_@xxx_fatal@4
$L64384:

; 154  : 			state.begin=FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 156  : 		else

	jmp	SHORT $L64389
$L64381:

; 158  : 			if (vbuffer->Lock(cur_off,lock_size,(U8 **)&vcur32,D3DLOCK_NOOVERWRITE)!=D3D_OK)

	push	4096					; 00001000H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _lock_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $L64389

; 159  : 				xxx_fatal("Unable to lock vertex buffer");

	mov	ecx, OFFSET FLAT:??_C@_0BN@CDMH@Unable?5to?5lock?5vertex?5buffer?$AA@ ; `string'
	call	DWORD PTR __imp_@xxx_fatal@4
$L64389:

; 161  : 		lock_end=cur_off+lock_size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, DWORD PTR _lock_size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], edx

; 162  : 		vindex=cur_off/(state.vsize*4);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	shr	ecx, 3
	and	ecx, 31					; 0000001fH
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	xor	edx, edx
	div	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 163  : 		state.has_lock=TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	or	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 164  : 		return vcur32;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]

; 165  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Lock@VBuffer@@QAEPAXK@Z ENDP				; VBuffer::Lock
_TEXT	ENDS
;	COMDAT ?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z
_TEXT	SEGMENT
_space$ = 8
_v$ = 12
_this$ = -4
?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z PROC NEAR ; VidD3D::set_vert_adv, COMDAT

; 446  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 447  : 		*space=*v;

	mov	esi, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _space$[ebp]
	mov	edi, DWORD PTR [eax]
	mov	ecx, 7
	rep movsd

; 448  : 		space++;

	mov	ecx, DWORD PTR _space$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _space$[ebp]
	mov	DWORD PTR [eax], edx

; 449  : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ENDP	; VidD3D::set_vert_adv
_TEXT	ENDS
PUBLIC	?end_prim@VManager@@QAEXPAUDxVertexT@@K@Z	; VManager::end_prim
;	COMDAT ?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z
_TEXT	SEGMENT
_space$ = 8
_count$ = 12
_this$ = -4
?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z PROC NEAR	; VidD3D::end_prim, COMDAT

; 451  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 452  : 		vbuffers->end_prim(space,count);

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _space$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?end_prim@VManager@@QAEXPAUDxVertexT@@K@Z ; VManager::end_prim

; 453  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z ENDP		; VidD3D::end_prim
_TEXT	ENDS
PUBLIC	??_C@_0BB@DDMK@Not?5in?5primitive?$AA@		; `string'
PUBLIC	??_C@_0BD@GDIC@bad?5primitive?5type?$AA@	; `string'
PUBLIC	??_C@_0CJ@MEJC@VManager?3?3end_prim?3?5DrawPrimitiv@ ; `string'
PUBLIC	?Unlock@VBuffer@@QAEXPAX@Z			; VBuffer::Unlock
;	COMDAT ??_C@_0BB@DDMK@Not?5in?5primitive?$AA@
; File D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidd3d.h
_DATA	SEGMENT
??_C@_0BB@DDMK@Not?5in?5primitive?$AA@ DB 'Not in primitive', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GDIC@bad?5primitive?5type?$AA@
_DATA	SEGMENT
??_C@_0BD@GDIC@bad?5primitive?5type?$AA@ DB 'bad primitive type', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@MEJC@VManager?3?3end_prim?3?5DrawPrimitiv@
_DATA	SEGMENT
??_C@_0CJ@MEJC@VManager?3?3end_prim?3?5DrawPrimitiv@ DB 'VManager::end_pr'
	DB	'im: DrawPrimitive failed', 00H		; `string'
_DATA	ENDS
;	COMDAT ?end_prim@VManager@@QAEXPAUDxVertexT@@K@Z
_TEXT	SEGMENT
_space$ = 8
_count$ = 12
_this$ = -4
?end_prim@VManager@@QAEXPAUDxVertexT@@K@Z PROC NEAR	; VManager::end_prim, COMDAT

; 245  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 246  : #ifdef DEBUG
; 247  : 		if (!state.in_prim)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L64513

; 248  : 			xxx_throw("Not in primitive");

	mov	ecx, OFFSET FLAT:??_C@_0BB@DDMK@Not?5in?5primitive?$AA@ ; `string'
	call	DWORD PTR __imp_@xxx_throw@4
$L64513:

; 249  : 		state.in_prim=FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	al, -2					; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 250  : 		if ((cur_prim.type!=PRIM_TRIANGLELIST)&&(cur_prim.type!=PRIM_LINELIST))

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+36]
	cmp	eax, 4
	je	SHORT $L64515
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+36]
	cmp	edx, 2
	je	SHORT $L64515

; 251  : 			xxx_fatal("bad primitive type");

	mov	ecx, OFFSET FLAT:??_C@_0BD@GDIC@bad?5primitive?5type?$AA@ ; `string'
	call	DWORD PTR __imp_@xxx_fatal@4
$L64515:

; 252  : #endif
; 253  : 		if (!count)

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $L64517

; 254  : 			return;

	jmp	SHORT $L64512
$L64517:

; 255  : 		cur->Unlock(space);

	mov	eax, DWORD PTR _space$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?Unlock@VBuffer@@QAEXPAX@Z		; VBuffer::Unlock

; 256  : 		if (dev->DrawPrimitive((D3DPRIMITIVETYPE)cur_prim.type,cur_prim.start,count)!=D3D_OK)

	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+280]
	test	eax, eax
	je	SHORT $L64520

; 257  : 			xxx_fatal("VManager::end_prim: DrawPrimitive failed");

	mov	ecx, OFFSET FLAT:??_C@_0CJ@MEJC@VManager?3?3end_prim?3?5DrawPrimitiv@ ; `string'
	call	DWORD PTR __imp_@xxx_fatal@4
$L64520:
$L64512:

; 258  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?end_prim@VManager@@QAEXPAUDxVertexT@@K@Z ENDP		; VManager::end_prim
_TEXT	ENDS
PUBLIC	??_C@_0DK@KCID@D?3?2Games?2duke_nukem_forever?2Hack@ ; `string'
PUBLIC	??_C@_0BP@NEML@Unable?5to?5unlock?5vertex?5buffer?$AA@ ; `string'
;	COMDAT ??_C@_0DK@KCID@D?3?2Games?2duke_nukem_forever?2Hack@
; File D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidd3d.h
_DATA	SEGMENT
??_C@_0DK@KCID@D?3?2Games?2duke_nukem_forever?2Hack@ DB 'D:\Games\duke_nu'
	DB	'kem_forever\Hacked\MeshEd\vidd3d\vidd3d.h', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@NEML@Unable?5to?5unlock?5vertex?5buffer?$AA@
_DATA	SEGMENT
??_C@_0BP@NEML@Unable?5to?5unlock?5vertex?5buffer?$AA@ DB 'Unable to unlo'
	DB	'ck vertex buffer', 00H			; `string'
_DATA	ENDS
;	COMDAT ?Unlock@VBuffer@@QAEXPAX@Z
_TEXT	SEGMENT
_this$ = -4
?Unlock@VBuffer@@QAEXPAX@Z PROC NEAR			; VBuffer::Unlock, COMDAT

; 167  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
$L64392:

; 168  : 		D_ASSERT(state.has_lock);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L64395
	push	168					; 000000a8H
	push	OFFSET FLAT:??_C@_0DK@KCID@D?3?2Games?2duke_nukem_forever?2Hack@ ; `string'
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L64395:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L64392

; 169  : 		if (vbuffer->Unlock()!=D3D_OK)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+48]
	test	eax, eax
	je	SHORT $L64399

; 170  : 			xxx_fatal("Unable to unlock vertex buffer");

	mov	ecx, OFFSET FLAT:??_C@_0BP@NEML@Unable?5to?5unlock?5vertex?5buffer?$AA@ ; `string'
	call	DWORD PTR __imp_@xxx_fatal@4
$L64399:

; 171  : 		cur_off=lock_end;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+20], edx

; 172  : 		vindex=cur_off/(state.vsize*4);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 3
	and	ecx, 31					; 0000001fH
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	xor	edx, edx
	div	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 173  : 		state.has_lock=FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	al, -2					; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 174  : 		//_fence();
; 175  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Unlock@VBuffer@@QAEXPAX@Z ENDP				; VBuffer::Unlock
_TEXT	ENDS
PUBLIC	__real@4@40008000000000000000
PUBLIC	?DrawLineBox@VidD3D@@UAEXPAUvector_str@@000@Z	; VidD3D::DrawLineBox
_DATA	SEGMENT
	ORG $+1
$SG65609 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65615 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
;	COMDAT __real@4@40008000000000000000
; File D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.cpp
CONST	SEGMENT
__real@4@40008000000000000000 DD 040000000r	; 2
CONST	ENDS
_TEXT	SEGMENT
_p1$ = 8
_p2$ = 12
_c1$ = 16
_c2$ = 20
_this$ = -136
_old_mode$ = -128
_v1$ = -28
_v2$ = -56
_v3$ = -84
_v4$ = -112
_avg$ = -124
_space$ = -132
?DrawLineBox@VidD3D@@UAEXPAUvector_str@@000@Z PROC NEAR	; VidD3D::DrawLineBox

; 603  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 604  : 	REND_POLY_BEGIN();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_begin_debug@VidD3D@@IAEXXZ	; VidD3D::rend_begin_debug
$L65604:

; 605  : 
; 606  : 	vidcolormodetype_t old_mode;
; 607  : 	DxVertexT v1,v2,v3,v4;
; 608  : 	vector_type avg;
; 609  : 
; 610  : 	D_ASSERT(p1);D_ASSERT(p2);

	cmp	DWORD PTR _p1$[ebp], 0
	jne	SHORT $L65607
	push	610					; 00000262H
	push	OFFSET FLAT:$SG65609
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65607:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L65604
$L65606:
	cmp	DWORD PTR _p2$[ebp], 0
	jne	SHORT $L65613
	push	610					; 00000262H
	push	OFFSET FLAT:$SG65615
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65613:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65606

; 611  : 
; 612  : 	old_mode=VCM_GOURAUD;

	mov	DWORD PTR _old_mode$[ebp], 1

; 613  : 	if (vid_state.color_mode!=VCM_GOURAUD)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 14					; 0000000eH
	and	eax, 7
	cmp	eax, 1
	je	SHORT $L65616

; 614  : 		old_mode=ColorMode(VCM_GOURAUD);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+72]
	mov	DWORD PTR _old_mode$[ebp], eax
$L65616:

; 615  : 
; 616  : 	if ((!c1)||(!c2))

	cmp	DWORD PTR _c1$[ebp], 0
	je	SHORT $L65618
	cmp	DWORD PTR _c2$[ebp], 0
	jne	SHORT $L65617
$L65618:

; 618  : 		v1.color=GetColor();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+52]
	mov	DWORD PTR _v1$[ebp+16], eax

; 619  : 		v2.color=v1.color;

	mov	eax, DWORD PTR _v1$[ebp+16]
	mov	DWORD PTR _v2$[ebp+16], eax

; 620  : 		v3.color=v1.color;

	mov	ecx, DWORD PTR _v1$[ebp+16]
	mov	DWORD PTR _v3$[ebp+16], ecx

; 621  : 		v4.color=v1.color;

	mov	edx, DWORD PTR _v1$[ebp+16]
	mov	DWORD PTR _v4$[ebp+16], edx

; 623  : 	else

	jmp	$L65619
$L65617:

; 625  : 		v1.color=VEC_TO_1RGB(*c1);

	mov	eax, DWORD PTR _c1$[ebp]
	fld	DWORD PTR [eax]
	call	__ftol
	mov	esi, eax
	and	esi, 255				; 000000ffH
	shl	esi, 16					; 00000010H
	or	esi, -16777216				; ff000000H
	mov	ecx, DWORD PTR _c1$[ebp]
	fld	DWORD PTR [ecx+4]
	call	__ftol
	and	eax, 255				; 000000ffH
	shl	eax, 8
	or	esi, eax
	mov	edx, DWORD PTR _c1$[ebp]
	fld	DWORD PTR [edx+8]
	call	__ftol
	and	eax, 255				; 000000ffH
	or	esi, eax
	mov	DWORD PTR _v1$[ebp+16], esi

; 626  : 		v2.color=VEC_TO_1RGB(*c2);

	mov	eax, DWORD PTR _c2$[ebp]
	fld	DWORD PTR [eax]
	call	__ftol
	mov	esi, eax
	and	esi, 255				; 000000ffH
	shl	esi, 16					; 00000010H
	or	esi, -16777216				; ff000000H
	mov	ecx, DWORD PTR _c2$[ebp]
	fld	DWORD PTR [ecx+4]
	call	__ftol
	and	eax, 255				; 000000ffH
	shl	eax, 8
	or	esi, eax
	mov	edx, DWORD PTR _c2$[ebp]
	fld	DWORD PTR [edx+8]
	call	__ftol
	and	eax, 255				; 000000ffH
	or	esi, eax
	mov	DWORD PTR _v2$[ebp+16], esi

; 627  : 		avg.x=(c1->x+c2->x)/2.0f;

	mov	eax, DWORD PTR _c1$[ebp]
	mov	ecx, DWORD PTR _c2$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	fdiv	DWORD PTR __real@4@40008000000000000000
	fstp	DWORD PTR _avg$[ebp]

; 628  : 		avg.y=(c1->y+c2->y)/2.0f;

	mov	edx, DWORD PTR _c1$[ebp]
	mov	eax, DWORD PTR _c2$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	fdiv	DWORD PTR __real@4@40008000000000000000
	fstp	DWORD PTR _avg$[ebp+4]

; 629  : 		avg.z=(c1->z+c2->z)/2.0f;

	mov	ecx, DWORD PTR _c1$[ebp]
	mov	edx, DWORD PTR _c2$[ebp]
	fld	DWORD PTR [ecx+8]
	fadd	DWORD PTR [edx+8]
	fdiv	DWORD PTR __real@4@40008000000000000000
	fstp	DWORD PTR _avg$[ebp+8]

; 630  : 		v3.color=VEC_TO_1RGB(avg);

	fld	DWORD PTR _avg$[ebp]
	call	__ftol
	mov	esi, eax
	and	esi, 255				; 000000ffH
	shl	esi, 16					; 00000010H
	or	esi, -16777216				; ff000000H
	fld	DWORD PTR _avg$[ebp+4]
	call	__ftol
	and	eax, 255				; 000000ffH
	shl	eax, 8
	or	esi, eax
	fld	DWORD PTR _avg$[ebp+8]
	call	__ftol
	and	eax, 255				; 000000ffH
	or	esi, eax
	mov	DWORD PTR _v3$[ebp+16], esi

; 631  : 		v4.color=v3.color;

	mov	eax, DWORD PTR _v3$[ebp+16]
	mov	DWORD PTR _v4$[ebp+16], eax
$L65619:

; 633  : 
; 634  : 	v1.z = v1.rhw = v2.z = v2.rhw = v3.z = v3.rhw = v4.z = v4.rhw = 1.0f;

	mov	DWORD PTR _v4$[ebp+12], 1065353216	; 3f800000H
	mov	ecx, DWORD PTR _v4$[ebp+12]
	mov	DWORD PTR _v4$[ebp+8], ecx
	mov	edx, DWORD PTR _v4$[ebp+8]
	mov	DWORD PTR _v3$[ebp+12], edx
	mov	eax, DWORD PTR _v3$[ebp+12]
	mov	DWORD PTR _v3$[ebp+8], eax
	mov	ecx, DWORD PTR _v3$[ebp+8]
	mov	DWORD PTR _v2$[ebp+12], ecx
	mov	edx, DWORD PTR _v2$[ebp+12]
	mov	DWORD PTR _v2$[ebp+8], edx
	mov	eax, DWORD PTR _v2$[ebp+8]
	mov	DWORD PTR _v1$[ebp+12], eax
	mov	ecx, DWORD PTR _v1$[ebp+12]
	mov	DWORD PTR _v1$[ebp+8], ecx

; 635  : 	if (vid_state.depth_enabled)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 7
	and	eax, 1
	test	eax, eax
	je	SHORT $L65629

; 637  : 		v1.z = p1->z; v1.rhw = 1.0f / v1.z;

	mov	ecx, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _v1$[ebp+8], edx
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _v1$[ebp+8]
	fstp	DWORD PTR _v1$[ebp+12]

; 638  : 		v2.z = p2->z; v2.rhw = 1.0f / v2.z;

	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _v2$[ebp+8], ecx
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _v2$[ebp+8]
	fstp	DWORD PTR _v2$[ebp+12]

; 639  : 		v3.z = v4.z = (p1->z+p2->z)/2.0f; v3.rhw = v4.rhw = 1.0f / v3.z;

	mov	edx, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR _p2$[ebp]
	fld	DWORD PTR [edx+8]
	fadd	DWORD PTR [eax+8]
	fdiv	DWORD PTR __real@4@40008000000000000000
	fstp	DWORD PTR _v4$[ebp+8]
	mov	ecx, DWORD PTR _v4$[ebp+8]
	mov	DWORD PTR _v3$[ebp+8], ecx
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _v3$[ebp+8]
	fstp	DWORD PTR _v4$[ebp+12]
	mov	edx, DWORD PTR _v4$[ebp+12]
	mov	DWORD PTR _v3$[ebp+12], edx
$L65629:

; 641  : 
; 642  : 	v1.x=p1->x;

	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _v1$[ebp], ecx

; 643  : 	v1.y=p1->y;

	mov	edx, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _v1$[ebp+4], eax

; 644  : 	v2.x=p1->x;

	mov	ecx, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _v2$[ebp], edx

; 645  : 	v2.y=p2->y;

	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _v2$[ebp+4], ecx

; 646  : 	v3.x=p2->x;

	mov	edx, DWORD PTR _p2$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _v3$[ebp], eax

; 647  : 	v3.y=p2->y;

	mov	ecx, DWORD PTR _p2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _v3$[ebp+4], edx

; 648  : 	v4.x=p2->x;

	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _v4$[ebp], ecx

; 649  : 	v4.y=p1->y;

	mov	edx, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _v4$[ebp+4], eax

; 650  : 
; 651  : 	DxVertexT *space=begin_prim(PRIM_LINELIST,4*2);

	push	8
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z ; VidD3D::begin_prim
	mov	DWORD PTR _space$[ebp], eax

; 652  : 	set_vert_adv(space,&v1);

	lea	ecx, DWORD PTR _v1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 653  : 	set_vert_adv(space,&v4);

	lea	eax, DWORD PTR _v4$[ebp]
	push	eax
	lea	ecx, DWORD PTR _space$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 654  : 	set_vert_adv(space,&v4);

	lea	edx, DWORD PTR _v4$[ebp]
	push	edx
	lea	eax, DWORD PTR _space$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 655  : 	set_vert_adv(space,&v3);

	lea	ecx, DWORD PTR _v3$[ebp]
	push	ecx
	lea	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 656  : 	set_vert_adv(space,&v3);

	lea	eax, DWORD PTR _v3$[ebp]
	push	eax
	lea	ecx, DWORD PTR _space$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 657  : 	set_vert_adv(space,&v2);

	lea	edx, DWORD PTR _v2$[ebp]
	push	edx
	lea	eax, DWORD PTR _space$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 658  : 	set_vert_adv(space,&v2);

	lea	ecx, DWORD PTR _v2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 659  : 	set_vert_adv(space,&v1);

	lea	eax, DWORD PTR _v1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _space$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 660  : 	end_prim(space,4);

	push	4
	mov	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z	; VidD3D::end_prim

; 661  : 
; 662  : 	if (old_mode!=VCM_GOURAUD)

	cmp	DWORD PTR _old_mode$[ebp], 1
	je	SHORT $L65631

; 663  : 		ColorMode(old_mode);

	mov	eax, DWORD PTR _old_mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+72]
$L65631:

; 664  : 
; 665  : 	REND_POLY_END();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_end_debug@VidD3D@@IAEXXZ		; VidD3D::rend_end_debug

; 666  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DrawLineBox@VidD3D@@UAEXPAUvector_str@@000@Z ENDP	; VidD3D::DrawLineBox
_TEXT	ENDS
PUBLIC	__real@4@3ff78080810000000000
PUBLIC	?DrawTriangle@VidD3D@@UAEXPAUvector_str@@0PAM0@Z ; VidD3D::DrawTriangle
;	COMDAT __real@4@3ff78080810000000000
; File D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.cpp
CONST	SEGMENT
__real@4@3ff78080810000000000 DD 03b808081r	; 0.00392157
CONST	ENDS
_TEXT	SEGMENT
_p$ = 8
_c$ = 12
_a$ = 16
_tv$ = 20
_this$ = -112
_verts$ = -84
_i$ = -92
_flat_color$65649 = -96
_flat_alpha$65660 = -100
_mod_s$65666 = -104
_mod_t$65667 = -108
_space$ = -88
?DrawTriangle@VidD3D@@UAEXPAUvector_str@@0PAM0@Z PROC NEAR ; VidD3D::DrawTriangle

; 669  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 670  : 	REND_POLY_BEGIN();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_begin_debug@VidD3D@@IAEXXZ	; VidD3D::rend_begin_debug

; 671  : 
; 672  : 	DxVertexT verts[3];
; 673  : 	U32 i;
; 674  : 
; 675  : 	if (c)

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $L65641

; 677  : 		for(i=0;i<3;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65642
$L65643:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L65642:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $L65644

; 678  : 			verts[i].color=VEC_TO_0RGB(c[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _c$[ebp]
	fld	DWORD PTR [edx+ecx]
	call	__ftol
	mov	esi, eax
	and	esi, 255				; 000000ffH
	shl	esi, 16					; 00000010H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _c$[ebp]
	fld	DWORD PTR [ecx+eax+4]
	call	__ftol
	and	eax, 255				; 000000ffH
	shl	eax, 8
	or	esi, eax
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _c$[ebp]
	fld	DWORD PTR [eax+edx+8]
	call	__ftol
	and	eax, 255				; 000000ffH
	or	esi, eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+ecx+16], esi
	jmp	SHORT $L65643
$L65644:

; 680  : 	else

	jmp	SHORT $L65653
$L65641:

; 682  : 		U32 flat_color=GetColor();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+52]
	mov	DWORD PTR _flat_color$65649[ebp], eax

; 683  : 		
; 684  : 		if (vid_state.color_mode!=VCM_FLAT)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 14					; 0000000eH
	and	edx, 7
	test	edx, edx
	je	SHORT $L65650

; 685  : 			flat_color=0x00FFFFFF;

	mov	DWORD PTR _flat_color$65649[ebp], 16777215 ; 00ffffffH
$L65650:

; 686  : 
; 687  : 		for(i=0;i<3;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65651
$L65652:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L65651:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $L65653

; 688  : 			verts[i].color=flat_color;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _flat_color$65649[ebp]
	mov	DWORD PTR _verts$[ebp+ecx+16], edx
	jmp	SHORT $L65652
$L65653:

; 690  : 	if (a)

	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $L65654

; 692  : 		for(i=0;i<3;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65655
$L65656:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L65655:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $L65657

; 693  : 			verts[i].color|=FLOAT_A_TO_A(a[i]);

	mov	esi, DWORD PTR _i$[ebp]
	imul	esi, 28					; 0000001cH
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [edx+ecx*4]
	call	__ftol
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _verts$[ebp+esi+16]
	or	ecx, eax
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+edx+16], ecx
	jmp	SHORT $L65656
$L65657:

; 695  : 	else

	jmp	SHORT $L65664
$L65654:

; 697  : 		U32 flat_alpha=GetColor() & 0xFF000000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+52]
	and	eax, -16777216				; ff000000H
	mov	DWORD PTR _flat_alpha$65660[ebp], eax

; 698  : 
; 699  : 		if (vid_state.alpha_mode!=VAM_FLAT)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 17					; 00000011H
	and	ecx, 7
	test	ecx, ecx
	je	SHORT $L65661

; 700  : 			flat_alpha=0xFF000000;

	mov	DWORD PTR _flat_alpha$65660[ebp], -16777216 ; ff000000H
$L65661:

; 701  : 
; 702  : 		for(i=0;i<3;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65662
$L65663:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65662:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $L65664

; 703  : 			verts[i].color|=flat_alpha;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _verts$[ebp+eax+16]
	or	ecx, DWORD PTR _flat_alpha$65660[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+edx+16], ecx
	jmp	SHORT $L65663
$L65664:

; 705  : 	if (tv)

	cmp	DWORD PTR _tv$[ebp], 0
	je	$L65675

; 707  : 		/* uber hack to get around glide'isms */
; 708  : 		/* need to convert tex coords from glide format to d3d's */
; 709  : 		float mod_s,mod_t;
; 710  : 
; 711  : 		mod_s=1.0f;

	mov	DWORD PTR _mod_s$65666[ebp], 1065353216	; 3f800000H

; 712  : 		mod_t=1.0f;

	mov	DWORD PTR _mod_t$65667[ebp], 1065353216	; 3f800000H

; 713  : 
; 714  : 		if (active_tex)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+300], 0
	je	SHORT $L65671

; 716  : 			/* if s major */
; 717  : 			if (active_tex->width >= active_tex->height)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	mov	edx, DWORD PTR [edx+8]
	cmp	edx, DWORD PTR [ecx+12]
	jb	SHORT $L65669

; 719  : 				mod_t*=(float)(active_tex->width/active_tex->height);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+300]
	mov	eax, DWORD PTR [ecx+8]
	xor	edx, edx
	div	DWORD PTR [esi+12]
	mov	DWORD PTR -120+[ebp], eax
	mov	DWORD PTR -120+[ebp+4], 0
	fild	QWORD PTR -120+[ebp]
	fmul	DWORD PTR _mod_t$65667[ebp]
	fstp	DWORD PTR _mod_t$65667[ebp]

; 721  : 			else /* if t major */

	jmp	SHORT $L65671
$L65669:

; 723  : 				mod_s*=(float)(active_tex->height/active_tex->width);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+300]
	mov	eax, DWORD PTR [ecx+12]
	xor	edx, edx
	div	DWORD PTR [esi+8]
	mov	DWORD PTR -128+[ebp], eax
	mov	DWORD PTR -128+[ebp+4], 0
	fild	QWORD PTR -128+[ebp]
	fmul	DWORD PTR _mod_s$65666[ebp]
	fstp	DWORD PTR _mod_s$65666[ebp]
$L65671:

; 726  : 		mod_s*=1.0f/255.0f;

	fld	DWORD PTR _mod_s$65666[ebp]
	fmul	DWORD PTR __real@4@3ff78080810000000000
	fstp	DWORD PTR _mod_s$65666[ebp]

; 727  : 		mod_t*=1.0f/255.0f;

	fld	DWORD PTR _mod_t$65667[ebp]
	fmul	DWORD PTR __real@4@3ff78080810000000000
	fstp	DWORD PTR _mod_t$65667[ebp]

; 728  : 		for(i=0;i<3;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65673
$L65674:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L65673:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $L65675

; 730  : 			verts[i].s=tv[i].x*mod_s;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _tv$[ebp]
	fld	DWORD PTR _mod_s$65666[ebp]
	fmul	DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	fstp	DWORD PTR _verts$[ebp+eax+20]

; 731  : 			verts[i].t=tv[i].y*mod_t;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _tv$[ebp]
	fld	DWORD PTR _mod_t$65667[ebp]
	fmul	DWORD PTR [edx+ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	fstp	DWORD PTR _verts$[ebp+eax+24]

; 732  : 		}

	jmp	SHORT $L65674
$L65675:

; 734  : 	for (i=0;i<3;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65676
$L65677:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L65676:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $L65678

; 736  : 		verts[i].x=p[i].x;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _verts$[ebp+eax], edx

; 737  : 		verts[i].y=p[i].y;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR _verts$[ebp+ecx+4], eax

; 738  : 		verts[i].z=verts[i].rhw=1.0f;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+ecx+12], 1065353216 ; 3f800000H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+edx+8], 1065353216 ; 3f800000H

; 739  : 	}

	jmp	SHORT $L65677
$L65678:

; 740  : 	if (vid_state.depth_enabled)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 7
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L65682

; 742  : 		for (i=0;i<3;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65680
$L65681:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65680:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $L65682

; 744  : 			verts[i].z=p[i].z;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR _verts$[ebp+ecx+8], eax

; 745  : 			verts[i].rhw = 1.0f / verts[i].z;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _verts$[ebp+ecx+8]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	fstp	DWORD PTR _verts$[ebp+edx+12]

; 746  : 		}

	jmp	SHORT $L65681
$L65682:

; 748  : 	DxVertexT *space=begin_prim(PRIM_TRIANGLELIST,3);

	push	3
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z ; VidD3D::begin_prim
	mov	DWORD PTR _space$[ebp], eax

; 749  : 	set_vert_adv(space,&verts[0]);

	lea	eax, DWORD PTR _verts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _space$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 750  : 	set_vert_adv(space,&verts[1]);

	lea	edx, DWORD PTR _verts$[ebp+28]
	push	edx
	lea	eax, DWORD PTR _space$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 751  : 	set_vert_adv(space,&verts[2]);

	lea	ecx, DWORD PTR _verts$[ebp+56]
	push	ecx
	lea	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 752  : 	end_prim(space,1);

	push	1
	mov	eax, DWORD PTR _space$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z	; VidD3D::end_prim

; 753  : 
; 754  : 	REND_POLY_END();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_end_debug@VidD3D@@IAEXXZ		; VidD3D::rend_end_debug

; 755  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DrawTriangle@VidD3D@@UAEXPAUvector_str@@0PAM0@Z ENDP	; VidD3D::DrawTriangle
_TEXT	ENDS
PUBLIC	?draw_polygon@VidD3D@@UAEXKPAVCVert@@@Z		; VidD3D::draw_polygon
_TEXT	SEGMENT
_num_verts$ = 8
_verts$ = 12
_this$ = -16
_num_tris$ = -4
_space$ = -12
_i$ = -8
?draw_polygon@VidD3D@@UAEXKPAVCVert@@@Z PROC NEAR	; VidD3D::draw_polygon

; 759  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 760  : 	U32 num_tris=(num_verts-2);

	mov	eax, DWORD PTR _num_verts$[ebp]
	sub	eax, 2
	mov	DWORD PTR _num_tris$[ebp], eax

; 761  : 	DxVertexT *space=begin_prim(PRIM_TRIANGLELIST,num_tris*3);

	mov	ecx, DWORD PTR _num_tris$[ebp]
	imul	ecx, 3
	push	ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z ; VidD3D::begin_prim
	mov	DWORD PTR _space$[ebp], eax

; 762  : 	for (U32 i=0;i<num_tris;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65692
$L65693:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65692:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num_tris$[ebp]
	jae	SHORT $L65694

; 764  : 		set_vert_adv(space,(DxVertexT *)&verts[0]);

	mov	ecx, DWORD PTR _verts$[ebp]
	push	ecx
	lea	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 765  : 		set_vert_adv(space,(DxVertexT *)&verts[i+1]);

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _verts$[ebp]
	add	ecx, eax
	push	ecx
	lea	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 766  : 		set_vert_adv(space,(DxVertexT *)&verts[i+2]);

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _verts$[ebp]
	add	ecx, eax
	push	ecx
	lea	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 767  : 	}

	jmp	SHORT $L65693
$L65694:

; 768  : 	end_prim(space,num_tris);

	mov	eax, DWORD PTR _num_tris$[ebp]
	push	eax
	mov	ecx, DWORD PTR _space$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z	; VidD3D::end_prim

; 769  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?draw_polygon@VidD3D@@UAEXKPAVCVert@@@Z ENDP		; VidD3D::draw_polygon
_TEXT	ENDS
PUBLIC	__real@4@3ffe8000000000000000
PUBLIC	__real@4@40098000000000000000
PUBLIC	?DrawClippedPolygon@VidD3D@@UAEXKPAUvector_str@@0PAM0@Z ; VidD3D::DrawClippedPolygon
_DATA	SEGMENT
	ORG $+1
$SG65711 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65769 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
;	COMDAT __real@4@3ffe8000000000000000
; File D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.cpp
CONST	SEGMENT
__real@4@3ffe8000000000000000 DD 03f000000r	; 0.5
CONST	ENDS
;	COMDAT __real@4@40098000000000000000
CONST	SEGMENT
__real@4@40098000000000000000 DD 044800000r	; 1024
CONST	ENDS
_TEXT	SEGMENT
_numverts$ = 8
_p$ = 12
_c$ = 16
_a$ = 20
_tv$ = 24
_this$ = -480
_verts$ = -452
_i$ = -460
_flat_color$65722 = -464
_flat_alpha$65733 = -468
_mod_s$65739 = -472
_mod_t$65740 = -476
_num_tris$ = -4
_space$ = -456
?DrawClippedPolygon@VidD3D@@UAEXKPAUvector_str@@0PAM0@Z PROC NEAR ; VidD3D::DrawClippedPolygon

; 772  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 496				; 000001f0H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 773  : 	REND_POLY_BEGIN();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_begin_debug@VidD3D@@IAEXXZ	; VidD3D::rend_begin_debug
$L65706:

; 774  : 
; 775  : 	D_ASSERT(numverts<16);

	cmp	DWORD PTR _numverts$[ebp], 16		; 00000010H
	jb	SHORT $L65709
	push	775					; 00000307H
	push	OFFSET FLAT:$SG65711
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65709:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L65706

; 776  : 
; 777  : 	DxVertexT verts[16];
; 778  : 	U32 i;
; 779  : 
; 780  : 	if (c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$L65714

; 782  : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65715
$L65716:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L65715:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65717

; 783  : 			verts[i].color=VEC_TO_0RGB(c[i]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _c$[ebp]
	fld	DWORD PTR [ecx+eax]
	call	__ftol
	mov	esi, eax
	and	esi, 255				; 000000ffH
	shl	esi, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _c$[ebp]
	fld	DWORD PTR [eax+edx+4]
	call	__ftol
	and	eax, 255				; 000000ffH
	shl	eax, 8
	or	esi, eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _c$[ebp]
	fld	DWORD PTR [edx+ecx+8]
	call	__ftol
	and	eax, 255				; 000000ffH
	or	esi, eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+eax+16], esi
	jmp	$L65716
$L65717:

; 785  : 	else

	jmp	SHORT $L65726
$L65714:

; 787  : 		U32 flat_color=GetColor();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+52]
	mov	DWORD PTR _flat_color$65722[ebp], eax

; 788  : 		
; 789  : 		if (vid_state.color_mode!=VCM_FLAT)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 14					; 0000000eH
	and	ecx, 7
	test	ecx, ecx
	je	SHORT $L65723

; 790  : 			flat_color=0x00FFFFFF;

	mov	DWORD PTR _flat_color$65722[ebp], 16777215 ; 00ffffffH
$L65723:

; 791  : 
; 792  : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65724
$L65725:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65724:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65726

; 793  : 			verts[i].color=flat_color;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _flat_color$65722[ebp]
	mov	DWORD PTR _verts$[ebp+ecx+16], edx
	jmp	SHORT $L65725
$L65726:

; 795  : 	if (a)

	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $L65727

; 797  : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65728
$L65729:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L65728:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65730

; 798  : 			verts[i].color|=FLOAT_A_TO_A(a[i]);

	mov	esi, DWORD PTR _i$[ebp]
	imul	esi, 28					; 0000001cH
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax+edx*4]
	call	__ftol
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _verts$[ebp+esi+16]
	or	ecx, eax
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+edx+16], ecx
	jmp	SHORT $L65729
$L65730:

; 800  : 	else

	jmp	$L65737
$L65727:

; 802  : 		U32 flat_alpha=GetColor() & 0xFF000000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+52]
	and	eax, -16777216				; ff000000H
	mov	DWORD PTR _flat_alpha$65733[ebp], eax

; 803  : 
; 804  : 		if (vid_state.alpha_mode!=VAM_FLAT)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 17					; 00000011H
	and	ecx, 7
	test	ecx, ecx
	je	SHORT $L65734

; 805  : 			flat_alpha=0xFF000000;

	mov	DWORD PTR _flat_alpha$65733[ebp], -16777216 ; ff000000H
$L65734:

; 806  : 
; 807  : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65735
$L65736:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65735:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65737

; 808  : 			verts[i].color|=flat_alpha;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _verts$[ebp+ecx+16]
	or	edx, DWORD PTR _flat_alpha$65733[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+eax+16], edx
	jmp	SHORT $L65736
$L65737:

; 810  : 	if (tv)

	cmp	DWORD PTR _tv$[ebp], 0
	je	$L65748

; 812  : 		/* uber hack to get around glide'isms */
; 813  : 		/* need to convert tex coords from glide format to d3d's */
; 814  : 		float mod_s,mod_t;
; 815  : 
; 816  : 		mod_s=1.0f;

	mov	DWORD PTR _mod_s$65739[ebp], 1065353216	; 3f800000H

; 817  : 		mod_t=1.0f;

	mov	DWORD PTR _mod_t$65740[ebp], 1065353216	; 3f800000H

; 818  : 
; 819  : 		if (active_tex)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+300], 0
	je	$L65744

; 821  : 			/* if s major */
; 822  : 			if (active_tex->width >= active_tex->height)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+300]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, DWORD PTR [edx+12]
	jb	SHORT $L65742

; 824  : 				mod_t*=(float)(active_tex->width/active_tex->height);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	mov	eax, DWORD PTR [edx+8]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	DWORD PTR -488+[ebp], eax
	mov	DWORD PTR -488+[ebp+4], 0
	fild	QWORD PTR -488+[ebp]
	fmul	DWORD PTR _mod_t$65740[ebp]
	fstp	DWORD PTR _mod_t$65740[ebp]

; 826  : 			else /* if t major */

	jmp	SHORT $L65744
$L65742:

; 828  : 				mod_s*=(float)(active_tex->height/active_tex->width);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+300]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+300]
	mov	eax, DWORD PTR [eax+12]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR -496+[ebp], eax
	mov	DWORD PTR -496+[ebp+4], 0
	fild	QWORD PTR -496+[ebp]
	fmul	DWORD PTR _mod_s$65739[ebp]
	fstp	DWORD PTR _mod_s$65739[ebp]
$L65744:

; 831  : 		mod_s*=1.0f/255.0f;

	fld	DWORD PTR _mod_s$65739[ebp]
	fmul	DWORD PTR __real@4@3ff78080810000000000
	fstp	DWORD PTR _mod_s$65739[ebp]

; 832  : 		mod_t*=1.0f/255.0f;

	fld	DWORD PTR _mod_t$65740[ebp]
	fmul	DWORD PTR __real@4@3ff78080810000000000
	fstp	DWORD PTR _mod_t$65740[ebp]

; 833  : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65746
$L65747:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65746:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65748

; 835  : 			verts[i].s=tv[i].x*mod_s;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _tv$[ebp]
	fld	DWORD PTR _mod_s$65739[ebp]
	fmul	DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	fstp	DWORD PTR _verts$[ebp+eax+20]

; 836  : 			verts[i].t=tv[i].y*mod_t;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _tv$[ebp]
	fld	DWORD PTR _mod_t$65740[ebp]
	fmul	DWORD PTR [edx+ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	fstp	DWORD PTR _verts$[ebp+eax+24]

; 837  : 		}

	jmp	SHORT $L65747
$L65748:

; 839  : 	for (i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65749
$L65750:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L65749:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65751

; 841  : 		verts[i].x=p[i].x;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _verts$[ebp+ecx], eax

; 842  : 		verts[i].y=p[i].y;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR _verts$[ebp+edx+4], ecx

; 843  : 		verts[i].z=verts[i].rhw=1.0f;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+edx+12], 1065353216 ; 3f800000H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+eax+8], 1065353216 ; 3f800000H

; 844  : 	}

	jmp	$L65750
$L65751:

; 845  : 	if (vid_state.depth_enabled)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 7
	and	edx, 1
	test	edx, edx
	je	$L65755

; 847  : 		for (i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65753
$L65754:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L65753:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numverts$[ebp]
	jae	$L65755

; 849  : 			//verts[i].z=((p[i].z)+0.5f) * (65535.0f/1024.5f);
; 850  : 			verts[i].z=p[i].z;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR _verts$[ebp+eax+8], edx

; 851  : 			verts[i].rhw = 1.0f / verts[i].z;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _verts$[ebp+eax+8]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	fstp	DWORD PTR _verts$[ebp+ecx+12]

; 852  : 			if ((p[i].z < 0.5f) || (p[i].z > 1024.0f))

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax+edx+8]
	fcomp	DWORD PTR __real@4@3ffe8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L65757
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [edx+ecx+8]
	fcomp	DWORD PTR __real@4@40098000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L65756
$L65757:

; 853  : 				_deb_val++;

	mov	eax, DWORD PTR ?_deb_val@@3KC		; _deb_val
	add	eax, 1
	mov	DWORD PTR ?_deb_val@@3KC, eax		; _deb_val
$L65756:

; 854  : 		}

	jmp	$L65754
$L65755:

; 856  : 
; 857  : 	U32 num_tris=(numverts-2);

	mov	ecx, DWORD PTR _numverts$[ebp]
	sub	ecx, 2
	mov	DWORD PTR _num_tris$[ebp], ecx

; 858  : 	DxVertexT *space=begin_prim(PRIM_TRIANGLELIST,num_tris*3);

	mov	edx, DWORD PTR _num_tris$[ebp]
	imul	edx, 3
	push	edx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z ; VidD3D::begin_prim
	mov	DWORD PTR _space$[ebp], eax

; 859  : 	for (i=0;i<num_tris;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65760
$L65761:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L65760:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _num_tris$[ebp]
	jae	SHORT $L65762

; 861  : 		set_vert_adv(space,&verts[0]);

	lea	edx, DWORD PTR _verts$[ebp]
	push	edx
	lea	eax, DWORD PTR _space$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 862  : 		set_vert_adv(space,&verts[i+1]);

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	imul	ecx, 28					; 0000001cH
	lea	edx, DWORD PTR _verts$[ebp+ecx]
	push	edx
	lea	eax, DWORD PTR _space$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 863  : 		set_vert_adv(space,&verts[i+2]);

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 2
	imul	ecx, 28					; 0000001cH
	lea	edx, DWORD PTR _verts$[ebp+ecx]
	push	edx
	lea	eax, DWORD PTR _space$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 864  : 	}

	jmp	$L65761
$L65762:

; 865  : 	end_prim(space,num_tris);

	mov	ecx, DWORD PTR _num_tris$[ebp]
	push	ecx
	mov	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z	; VidD3D::end_prim
$L65763:

; 866  : 	D_ASSERT(((I32)num_tris > 0));

	cmp	DWORD PTR _num_tris$[ebp], 0
	jg	SHORT $L65767
	push	866					; 00000362H
	push	OFFSET FLAT:$SG65769
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65767:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L65763

; 867  : 
; 868  : 	REND_POLY_END();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_end_debug@VidD3D@@IAEXXZ		; VidD3D::rend_end_debug

; 869  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?DrawClippedPolygon@VidD3D@@UAEXKPAUvector_str@@0PAM0@Z ENDP ; VidD3D::DrawClippedPolygon
_TEXT	ENDS
PUBLIC	?DrawPolygon@VidD3D@@UAEXKPAUvector_str@@0PAM0@Z ; VidD3D::DrawPolygon
_DATA	SEGMENT
	ORG $+1
$SG65783 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65841 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_numverts$ = 8
_p$ = 12
_c$ = 16
_a$ = 20
_tv$ = 24
_this$ = -480
_verts$ = -452
_i$ = -460
_flat_color$65794 = -464
_flat_alpha$65805 = -468
_mod_s$65811 = -472
_mod_t$65812 = -476
_num_tris$ = -4
_space$ = -456
?DrawPolygon@VidD3D@@UAEXKPAUvector_str@@0PAM0@Z PROC NEAR ; VidD3D::DrawPolygon

; 872  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 496				; 000001f0H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 873  : 	REND_POLY_BEGIN();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_begin_debug@VidD3D@@IAEXXZ	; VidD3D::rend_begin_debug
$L65778:

; 874  : 
; 875  : 	D_ASSERT(numverts<16);

	cmp	DWORD PTR _numverts$[ebp], 16		; 00000010H
	jb	SHORT $L65781
	push	875					; 0000036bH
	push	OFFSET FLAT:$SG65783
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65781:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L65778

; 876  : 
; 877  : 	DxVertexT verts[16];
; 878  : 	U32 i;
; 879  : 
; 880  : 	if (c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$L65786

; 882  : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65787
$L65788:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L65787:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65789

; 883  : 			verts[i].color=VEC_TO_0RGB(c[i]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _c$[ebp]
	fld	DWORD PTR [ecx+eax]
	call	__ftol
	mov	esi, eax
	and	esi, 255				; 000000ffH
	shl	esi, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _c$[ebp]
	fld	DWORD PTR [eax+edx+4]
	call	__ftol
	and	eax, 255				; 000000ffH
	shl	eax, 8
	or	esi, eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _c$[ebp]
	fld	DWORD PTR [edx+ecx+8]
	call	__ftol
	and	eax, 255				; 000000ffH
	or	esi, eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+eax+16], esi
	jmp	$L65788
$L65789:

; 885  : 	else

	jmp	SHORT $L65798
$L65786:

; 887  : 		U32 flat_color=GetColor();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+52]
	mov	DWORD PTR _flat_color$65794[ebp], eax

; 888  : 		
; 889  : 		if (vid_state.color_mode!=VCM_FLAT)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 14					; 0000000eH
	and	ecx, 7
	test	ecx, ecx
	je	SHORT $L65795

; 890  : 			flat_color=0x00FFFFFF;

	mov	DWORD PTR _flat_color$65794[ebp], 16777215 ; 00ffffffH
$L65795:

; 891  : 
; 892  : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65796
$L65797:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65796:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65798

; 893  : 			verts[i].color=flat_color;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _flat_color$65794[ebp]
	mov	DWORD PTR _verts$[ebp+ecx+16], edx
	jmp	SHORT $L65797
$L65798:

; 895  : 	if (a)

	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $L65799

; 897  : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65800
$L65801:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L65800:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65802

; 898  : 			verts[i].color|=FLOAT_A_TO_A(a[i]);

	mov	esi, DWORD PTR _i$[ebp]
	imul	esi, 28					; 0000001cH
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax+edx*4]
	call	__ftol
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _verts$[ebp+esi+16]
	or	ecx, eax
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+edx+16], ecx
	jmp	SHORT $L65801
$L65802:

; 900  : 	else

	jmp	$L65809
$L65799:

; 902  : 		U32 flat_alpha=GetColor() & 0xFF000000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+52]
	and	eax, -16777216				; ff000000H
	mov	DWORD PTR _flat_alpha$65805[ebp], eax

; 903  : 
; 904  : 		if (vid_state.alpha_mode!=VAM_FLAT)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 17					; 00000011H
	and	ecx, 7
	test	ecx, ecx
	je	SHORT $L65806

; 905  : 			flat_alpha=0xFF000000;

	mov	DWORD PTR _flat_alpha$65805[ebp], -16777216 ; ff000000H
$L65806:

; 906  : 
; 907  : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65807
$L65808:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65807:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65809

; 908  : 			verts[i].color|=flat_alpha;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _verts$[ebp+ecx+16]
	or	edx, DWORD PTR _flat_alpha$65805[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+eax+16], edx
	jmp	SHORT $L65808
$L65809:

; 910  : 	if (tv)

	cmp	DWORD PTR _tv$[ebp], 0
	je	$L65820

; 912  : 		/* uber hack to get around glide'isms */
; 913  : 		/* need to convert tex coords from glide format to d3d's */
; 914  : 		float mod_s,mod_t;
; 915  : 
; 916  : 		mod_s=1.0f;

	mov	DWORD PTR _mod_s$65811[ebp], 1065353216	; 3f800000H

; 917  : 		mod_t=1.0f;

	mov	DWORD PTR _mod_t$65812[ebp], 1065353216	; 3f800000H

; 918  : 
; 919  : 		if (active_tex)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+300], 0
	je	$L65816

; 921  : 			/* if s major */
; 922  : 			if (active_tex->width >= active_tex->height)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+300]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, DWORD PTR [edx+12]
	jb	SHORT $L65814

; 924  : 				mod_t*=(float)(active_tex->width/active_tex->height);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	mov	eax, DWORD PTR [edx+8]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	DWORD PTR -488+[ebp], eax
	mov	DWORD PTR -488+[ebp+4], 0
	fild	QWORD PTR -488+[ebp]
	fmul	DWORD PTR _mod_t$65812[ebp]
	fstp	DWORD PTR _mod_t$65812[ebp]

; 926  : 			else /* if t major */

	jmp	SHORT $L65816
$L65814:

; 928  : 				mod_s*=(float)(active_tex->height/active_tex->width);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+300]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+300]
	mov	eax, DWORD PTR [eax+12]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR -496+[ebp], eax
	mov	DWORD PTR -496+[ebp+4], 0
	fild	QWORD PTR -496+[ebp]
	fmul	DWORD PTR _mod_s$65811[ebp]
	fstp	DWORD PTR _mod_s$65811[ebp]
$L65816:

; 931  : 		mod_s*=1.0f/255.0f;

	fld	DWORD PTR _mod_s$65811[ebp]
	fmul	DWORD PTR __real@4@3ff78080810000000000
	fstp	DWORD PTR _mod_s$65811[ebp]

; 932  : 		mod_t*=1.0f/255.0f;

	fld	DWORD PTR _mod_t$65812[ebp]
	fmul	DWORD PTR __real@4@3ff78080810000000000
	fstp	DWORD PTR _mod_t$65812[ebp]

; 933  : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65818
$L65819:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65818:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65820

; 935  : 			verts[i].s=tv[i].x*mod_s;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _tv$[ebp]
	fld	DWORD PTR _mod_s$65811[ebp]
	fmul	DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	fstp	DWORD PTR _verts$[ebp+eax+20]

; 936  : 			verts[i].t=tv[i].y*mod_t;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _tv$[ebp]
	fld	DWORD PTR _mod_t$65812[ebp]
	fmul	DWORD PTR [edx+ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	fstp	DWORD PTR _verts$[ebp+eax+24]

; 937  : 		}

	jmp	SHORT $L65819
$L65820:

; 939  : 	for (i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65821
$L65822:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L65821:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numverts$[ebp]
	jae	$L65823

; 941  : 		_clip_sanity_vector(&p[i]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, eax
	push	ecx
	call	?_clip_sanity_vector@@YAXPAUvector_str@@@Z ; _clip_sanity_vector
	add	esp, 4

; 942  : 
; 943  : 		verts[i].x=p[i].x;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _verts$[ebp+eax], edx

; 944  : 		verts[i].y=p[i].y;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR _verts$[ebp+ecx+4], eax

; 945  : 		verts[i].z=verts[i].rhw=1.0f;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+ecx+12], 1065353216 ; 3f800000H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+edx+8], 1065353216 ; 3f800000H

; 946  : 	}

	jmp	$L65822
$L65823:

; 947  : 	if (vid_state.depth_enabled)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 7
	and	ecx, 1
	test	ecx, ecx
	je	$L65827

; 949  : 		for (i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65825
$L65826:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65825:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jae	$L65827

; 951  : 			//verts[i].z=((p[i].z)+0.5f) * (65535.0f/1024.5f);
; 952  : 			verts[i].z=p[i].z;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR _verts$[ebp+edx+8], ecx

; 953  : 			verts[i].rhw = 1.0f / verts[i].z;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _verts$[ebp+edx+8]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	fstp	DWORD PTR _verts$[ebp+eax+12]

; 954  : 			if ((p[i].z < 0.5f) || (p[i].z > 1024.0f))

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [edx+ecx+8]
	fcomp	DWORD PTR __real@4@3ffe8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L65829
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [ecx+eax+8]
	fcomp	DWORD PTR __real@4@40098000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L65828
$L65829:

; 955  : 				_deb_val++;

	mov	edx, DWORD PTR ?_deb_val@@3KC		; _deb_val
	add	edx, 1
	mov	DWORD PTR ?_deb_val@@3KC, edx		; _deb_val
$L65828:

; 956  : 		}

	jmp	$L65826
$L65827:

; 958  : 
; 959  : #if 1
; 960  : 	U32 num_tris=(numverts-2);

	mov	eax, DWORD PTR _numverts$[ebp]
	sub	eax, 2
	mov	DWORD PTR _num_tris$[ebp], eax

; 961  : 	DxVertexT *space=begin_prim(PRIM_TRIANGLELIST,num_tris*3);

	mov	ecx, DWORD PTR _num_tris$[ebp]
	imul	ecx, 3
	push	ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z ; VidD3D::begin_prim
	mov	DWORD PTR _space$[ebp], eax

; 962  : 	for (i=0;i<num_tris;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65832
$L65833:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65832:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num_tris$[ebp]
	jae	SHORT $L65834

; 964  : 		set_vert_adv(space,&verts[0]);

	lea	ecx, DWORD PTR _verts$[ebp]
	push	ecx
	lea	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 965  : 		set_vert_adv(space,&verts[i+1]);

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	imul	eax, 28					; 0000001cH
	lea	ecx, DWORD PTR _verts$[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 966  : 		set_vert_adv(space,&verts[i+2]);

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	imul	eax, 28					; 0000001cH
	lea	ecx, DWORD PTR _verts$[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 967  : 	}

	jmp	$L65833
$L65834:

; 968  : 	end_prim(space,num_tris);

	mov	eax, DWORD PTR _num_tris$[ebp]
	push	eax
	mov	ecx, DWORD PTR _space$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z	; VidD3D::end_prim
$L65835:

; 969  : 	D_ASSERT(((I32)num_tris > 0));

	cmp	DWORD PTR _num_tris$[ebp], 0
	jg	SHORT $L65839
	push	969					; 000003c9H
	push	OFFSET FLAT:$SG65841
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65839:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L65835

; 970  : #else
; 971  : 	DxVertexT *space=begin_prim(PRIM_TRIANGLELIST,3);
; 972  : 	set_vert_adv(space,&verts[0]);
; 973  : 	set_vert_adv(space,&verts[1]);
; 974  : 	set_vert_adv(space,&verts[2]);
; 975  : 	end_prim(space,1);
; 976  : #endif
; 977  : 	
; 978  : 	REND_POLY_END();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_end_debug@VidD3D@@IAEXXZ		; VidD3D::rend_end_debug

; 979  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?DrawPolygon@VidD3D@@UAEXKPAUvector_str@@0PAM0@Z ENDP	; VidD3D::DrawPolygon
_TEXT	ENDS
EXTRN	__rotl:NEAR
_BSS	SEGMENT
_old_x	DD	01H DUP (?)
_old_y	DD	01H DUP (?)
_old_width DD	01H DUP (?)
_old_height DD	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_this$ = -4
?rend_begin_debug@VidD3D@@IAEXXZ PROC NEAR		; VidD3D::rend_begin_debug

; 984  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 985  : 	if (_deb_rend)

	cmp	DWORD PTR ?_deb_rend@@3KC, 0		; _deb_rend
	je	SHORT $L65850

; 987  : 		old_x=vid_state.clip_x;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+16]
	mov	DWORD PTR _old_x, ecx

; 988  : 		old_y=vid_state.clip_y;

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+18]
	mov	DWORD PTR _old_y, eax

; 989  : 		old_width=vid_state.clip_width;

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+20]
	mov	DWORD PTR _old_width, edx

; 990  : 		old_height=vid_state.clip_height;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+22]
	mov	DWORD PTR _old_height, ecx

; 991  : 
; 992  : 		ClipWindow(0,0,res.width,res.height);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+32]

; 993  : 		
; 994  : 		ClearScreen(0);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+28]

; 995  : 		poly_clear=_rotl(poly_clear,8);

	push	8
	mov	eax, DWORD PTR _poly_clear
	push	eax
	call	__rotl
	add	esp, 8
	mov	DWORD PTR _poly_clear, eax
$L65850:

; 997  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?rend_begin_debug@VidD3D@@IAEXXZ ENDP			; VidD3D::rend_begin_debug
_this$ = -4
?rend_end_debug@VidD3D@@IAEXXZ PROC NEAR		; VidD3D::rend_end_debug

; 1000 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1001 : 	if (_deb_rend)

	cmp	DWORD PTR ?_deb_rend@@3KC, 0		; _deb_rend
	je	SHORT $L65855

; 1003 : 		vbuffers->flush();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 1004 : 		Swap();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+24]

; 1005 : 
; 1006 : 		ClipWindow(old_x,old_y,old_x+old_width,old_y+old_height);

	mov	eax, DWORD PTR _old_y
	add	eax, DWORD PTR _old_height
	push	eax
	mov	ecx, DWORD PTR _old_x
	add	ecx, DWORD PTR _old_width
	push	ecx
	mov	edx, DWORD PTR _old_y
	push	edx
	mov	eax, DWORD PTR _old_x
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+32]
$L65855:

; 1008 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?rend_end_debug@VidD3D@@IAEXXZ ENDP			; VidD3D::rend_end_debug
_TEXT	ENDS
PUBLIC	?DrawPolygonFlags@VidD3D@@UAEXKKPAUvector_str@@0PAM0@Z ; VidD3D::DrawPolygonFlags
_DATA	SEGMENT
	ORG $+1
$SG65870 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65926 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_numverts$ = 12
_p$ = 16
_c$ = 20
_a$ = 24
_tv$ = 28
_this$ = -480
_verts$ = -452
_i$ = -460
_flat_color$65881 = -464
_flat_alpha$65892 = -468
_mod_s$65898 = -472
_mod_t$65899 = -476
_num_tris$ = -4
_space$ = -456
?DrawPolygonFlags@VidD3D@@UAEXKKPAUvector_str@@0PAM0@Z PROC NEAR ; VidD3D::DrawPolygonFlags

; 1011 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 496				; 000001f0H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1012 : 	REND_POLY_BEGIN();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_begin_debug@VidD3D@@IAEXXZ	; VidD3D::rend_begin_debug
$L65865:

; 1013 : 
; 1014 : 	D_ASSERT(numverts<16);

	cmp	DWORD PTR _numverts$[ebp], 16		; 00000010H
	jb	SHORT $L65868
	push	1014					; 000003f6H
	push	OFFSET FLAT:$SG65870
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65868:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L65865

; 1015 : 
; 1016 : #if 0
; 1017 : 	vidatestmodetype_t atest;
; 1018 : 	if (flags & TF_TEXBLEND)
; 1019 : 		atest=AlphaTestMode(VCMP_GREATER);
; 1020 : #endif
; 1021 : 
; 1022 : 	DxVertexT verts[16];
; 1023 : 	U32 i;
; 1024 : 
; 1025 : 	if (c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$L65873

; 1027 : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65874
$L65875:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L65874:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65876

; 1028 : 			verts[i].color=VEC_TO_0RGB(c[i]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _c$[ebp]
	fld	DWORD PTR [ecx+eax]
	call	__ftol
	mov	esi, eax
	and	esi, 255				; 000000ffH
	shl	esi, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _c$[ebp]
	fld	DWORD PTR [eax+edx+4]
	call	__ftol
	and	eax, 255				; 000000ffH
	shl	eax, 8
	or	esi, eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _c$[ebp]
	fld	DWORD PTR [edx+ecx+8]
	call	__ftol
	and	eax, 255				; 000000ffH
	or	esi, eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+eax+16], esi
	jmp	$L65875
$L65876:

; 1030 : 	else

	jmp	SHORT $L65885
$L65873:

; 1032 : 		U32 flat_color=GetColor();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+52]
	mov	DWORD PTR _flat_color$65881[ebp], eax

; 1033 : 		
; 1034 : 		if (vid_state.color_mode!=VCM_FLAT)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 14					; 0000000eH
	and	ecx, 7
	test	ecx, ecx
	je	SHORT $L65882

; 1035 : 			flat_color=0x00FFFFFF;

	mov	DWORD PTR _flat_color$65881[ebp], 16777215 ; 00ffffffH
$L65882:

; 1036 : 
; 1037 : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65883
$L65884:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65883:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65885

; 1038 : 			verts[i].color=flat_color;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _flat_color$65881[ebp]
	mov	DWORD PTR _verts$[ebp+ecx+16], edx
	jmp	SHORT $L65884
$L65885:

; 1040 : 	if (a)

	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $L65886

; 1042 : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65887
$L65888:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L65887:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65889

; 1043 : 			verts[i].color|=FLOAT_A_TO_A(a[i]);

	mov	esi, DWORD PTR _i$[ebp]
	imul	esi, 28					; 0000001cH
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax+edx*4]
	call	__ftol
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _verts$[ebp+esi+16]
	or	ecx, eax
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+edx+16], ecx
	jmp	SHORT $L65888
$L65889:

; 1045 : 	else

	jmp	$L65896
$L65886:

; 1047 : 		U32 flat_alpha=GetColor() & 0xFF000000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+52]
	and	eax, -16777216				; ff000000H
	mov	DWORD PTR _flat_alpha$65892[ebp], eax

; 1048 : 
; 1049 : 		if (vid_state.alpha_mode!=VAM_FLAT)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 17					; 00000011H
	and	ecx, 7
	test	ecx, ecx
	je	SHORT $L65893

; 1050 : 			flat_alpha=0xFF000000;

	mov	DWORD PTR _flat_alpha$65892[ebp], -16777216 ; ff000000H
$L65893:

; 1051 : 
; 1052 : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65894
$L65895:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65894:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65896

; 1053 : 			verts[i].color|=flat_alpha;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _verts$[ebp+ecx+16]
	or	edx, DWORD PTR _flat_alpha$65892[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+eax+16], edx
	jmp	SHORT $L65895
$L65896:

; 1055 : 	if (tv)

	cmp	DWORD PTR _tv$[ebp], 0
	je	$L65907

; 1057 : 		/* uber hack to get around glide'isms */
; 1058 : 		/* need to convert tex coords from glide format to d3d's */
; 1059 : 		float mod_s,mod_t;
; 1060 : 
; 1061 : 		mod_s=1.0f;

	mov	DWORD PTR _mod_s$65898[ebp], 1065353216	; 3f800000H

; 1062 : 		mod_t=1.0f;

	mov	DWORD PTR _mod_t$65899[ebp], 1065353216	; 3f800000H

; 1063 : 
; 1064 : 		if (active_tex)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+300], 0
	je	$L65903

; 1066 : 			/* if s major */
; 1067 : 			if (active_tex->width >= active_tex->height)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+300]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, DWORD PTR [edx+12]
	jb	SHORT $L65901

; 1069 : 				mod_t*=(float)(active_tex->width/active_tex->height);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	mov	eax, DWORD PTR [edx+8]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	DWORD PTR -488+[ebp], eax
	mov	DWORD PTR -488+[ebp+4], 0
	fild	QWORD PTR -488+[ebp]
	fmul	DWORD PTR _mod_t$65899[ebp]
	fstp	DWORD PTR _mod_t$65899[ebp]

; 1071 : 			else /* if t major */

	jmp	SHORT $L65903
$L65901:

; 1073 : 				mod_s*=(float)(active_tex->height/active_tex->width);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+300]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+300]
	mov	eax, DWORD PTR [eax+12]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR -496+[ebp], eax
	mov	DWORD PTR -496+[ebp+4], 0
	fild	QWORD PTR -496+[ebp]
	fmul	DWORD PTR _mod_s$65898[ebp]
	fstp	DWORD PTR _mod_s$65898[ebp]
$L65903:

; 1076 : 		mod_s*=1.0f/255.0f;

	fld	DWORD PTR _mod_s$65898[ebp]
	fmul	DWORD PTR __real@4@3ff78080810000000000
	fstp	DWORD PTR _mod_s$65898[ebp]

; 1077 : 		mod_t*=1.0f/255.0f;

	fld	DWORD PTR _mod_t$65899[ebp]
	fmul	DWORD PTR __real@4@3ff78080810000000000
	fstp	DWORD PTR _mod_t$65899[ebp]

; 1078 : 		for(i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65905
$L65906:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L65905:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65907

; 1080 : 			verts[i].s=tv[i].x*mod_s;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _tv$[ebp]
	fld	DWORD PTR _mod_s$65898[ebp]
	fmul	DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	fstp	DWORD PTR _verts$[ebp+eax+20]

; 1081 : 			verts[i].t=tv[i].y*mod_t;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _tv$[ebp]
	fld	DWORD PTR _mod_t$65899[ebp]
	fmul	DWORD PTR [edx+ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	fstp	DWORD PTR _verts$[ebp+eax+24]

; 1082 : 		}

	jmp	SHORT $L65906
$L65907:

; 1084 : 	for (i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65908
$L65909:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L65908:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65910

; 1086 : 		verts[i].x=p[i].x;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _verts$[ebp+ecx], eax

; 1087 : 		verts[i].y=p[i].y;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR _verts$[ebp+edx+4], ecx

; 1088 : 		verts[i].z=verts[i].rhw=1.0f;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+edx+12], 1065353216 ; 3f800000H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	DWORD PTR _verts$[ebp+eax+8], 1065353216 ; 3f800000H

; 1089 : 	}

	jmp	$L65909
$L65910:

; 1090 : 	if (vid_state.depth_enabled)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 7
	and	edx, 1
	test	edx, edx
	je	SHORT $L65914

; 1092 : 		for (i=0;i<numverts;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65912
$L65913:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L65912:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numverts$[ebp]
	jae	SHORT $L65914

; 1094 : 			verts[i].z=p[i].z;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR _verts$[ebp+eax+8], edx

; 1095 : 			verts[i].rhw = 1.0f / verts[i].z;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _verts$[ebp+eax+8]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	fstp	DWORD PTR _verts$[ebp+ecx+12]

; 1096 : 		}

	jmp	SHORT $L65913
$L65914:

; 1098 : 
; 1099 : 	U32 num_tris=(numverts-2);

	mov	edx, DWORD PTR _numverts$[ebp]
	sub	edx, 2
	mov	DWORD PTR _num_tris$[ebp], edx

; 1100 : 	DxVertexT *space=begin_prim(PRIM_TRIANGLELIST,num_tris*3);

	mov	eax, DWORD PTR _num_tris$[ebp]
	imul	eax, 3
	push	eax
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z ; VidD3D::begin_prim
	mov	DWORD PTR _space$[ebp], eax

; 1101 : 	for (i=0;i<num_tris;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L65917
$L65918:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L65917:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _num_tris$[ebp]
	jae	SHORT $L65919

; 1103 : 		set_vert_adv(space,&verts[0]);

	lea	eax, DWORD PTR _verts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _space$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 1104 : 		set_vert_adv(space,&verts[i+1]);

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	imul	edx, 28					; 0000001cH
	lea	eax, DWORD PTR _verts$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR _space$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 1105 : 		set_vert_adv(space,&verts[i+2]);

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 2
	imul	edx, 28					; 0000001cH
	lea	eax, DWORD PTR _verts$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR _space$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 1106 : 	}

	jmp	$L65918
$L65919:

; 1107 : 	end_prim(space,num_tris);

	mov	edx, DWORD PTR _num_tris$[ebp]
	push	edx
	mov	eax, DWORD PTR _space$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z	; VidD3D::end_prim
$L65920:

; 1108 : 	D_ASSERT(((I32)num_tris > 0));

	cmp	DWORD PTR _num_tris$[ebp], 0
	jg	SHORT $L65924
	push	1108					; 00000454H
	push	OFFSET FLAT:$SG65926
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65924:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65920

; 1109 : 
; 1110 : #if 0
; 1111 : 	if (flags & TF_TEXBLEND)
; 1112 : 		AlphaTestMode(atest);
; 1113 : #endif
; 1114 : 
; 1115 : 	REND_POLY_END();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_end_debug@VidD3D@@IAEXXZ		; VidD3D::rend_end_debug

; 1116 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?DrawPolygonFlags@VidD3D@@UAEXKKPAUvector_str@@0PAM0@Z ENDP ; VidD3D::DrawPolygonFlags
_TEXT	ENDS
PUBLIC	?get_letter@XFont@@QAEXDPAM0@Z			; XFont::get_letter
PUBLIC	?get_pitch@XFont@@QAEXPAM0@Z			; XFont::get_pitch
PUBLIC	?DrawString@VidD3D@@UAEXHHHHPADEHHH@Z		; VidD3D::DrawString
EXTRN	__imp_@fstrlen@4:NEAR
_DATA	SEGMENT
	ORG $+1
$SG65944 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_x1$ = 8
_y1$ = 12
_dx$ = 16
_dy$ = 20
_str$ = 24
_filtered$ = 28
_this$ = -176
_len$ = -148
_verts$ = -124
_cmode$ = -136
_fmode$ = -164
_amode$ = -132
_bmode$ = -160
_atmode$ = -12
_l_width$ = -156
_l_height$ = -4
_dxf$ = -152
_dyf$ = -8
_key$ = -128
_space$ = -144
_tri_count$ = -140
_s$65976 = -168
_t$65977 = -172
?DrawString@VidD3D@@UAEXHHHHPADEHHH@Z PROC NEAR		; VidD3D::DrawString

; 1119 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	mov	DWORD PTR _this$[ebp], ecx

; 1120 : 	REND_POLY_BEGIN();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_begin_debug@VidD3D@@IAEXXZ	; VidD3D::rend_begin_debug
$L65939:

; 1121 : 
; 1122 : 	/* validate that depth is not enabled */
; 1123 : 	D_ASSERT(!vid_state.depth_enabled);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 7
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L65942
	push	1123					; 00000463H
	push	OFFSET FLAT:$SG65944
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65942:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L65939

; 1124 : 
; 1125 : 	if (!str)

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $L65945

; 1126 : 		return;

	jmp	$L65938
$L65945:

; 1127 : 
; 1128 : 	U32 len=fstrlen(str);

	mov	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_@fstrlen@4
	mov	DWORD PTR _len$[ebp], eax

; 1129 : 	if (!len)

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $L65947

; 1130 : 		return;

	jmp	$L65938
$L65947:

; 1133 : 
; 1134 : 	/* select font texture */
; 1135 : 	TexActivate(font,VTA_NORMAL);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+164]

; 1136 : 	
; 1137 : 	vidcolormodetype_t	cmode;
; 1138 : 	vidfiltermodetype_t fmode;
; 1139 : 	vidalphamodetype_t	amode;
; 1140 : 	vidblendmodetype_t	bmode;
; 1141 : 	vidatestmodetype_t	atmode;
; 1142 : 
; 1143 : 	/* setup masked alpha texture settings */
; 1144 : 	cmode=ColorMode(VCM_TEXTURE);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+72]
	mov	DWORD PTR _cmode$[ebp], eax

; 1145 : 	atmode=AlphaTestMode(VCMP_NOTEQUAL);

	push	6
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+96]
	mov	DWORD PTR _atmode$[ebp], eax

; 1146 : 	AlphaTestValue(0);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+68]

; 1147 : 	amode=AlphaMode(VAM_TEXTURE);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+76]
	mov	DWORD PTR _amode$[ebp], eax

; 1148 : 	bmode=BlendMode(VBM_OPAQUE);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]
	mov	DWORD PTR _bmode$[ebp], eax

; 1149 : 	if (filtered)

	mov	eax, DWORD PTR _filtered$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L65954

; 1150 : 		fmode = MagFilterMode(VFM_BILINEAR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+92]
	mov	DWORD PTR _fmode$[ebp], eax

; 1151 : 	else

	jmp	SHORT $L65955
$L65954:

; 1152 : 		fmode = MagFilterMode(VFM_POINT);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+92]
	mov	DWORD PTR _fmode$[ebp], eax
$L65955:

; 1153 : 
; 1154 : 	float l_width,l_height;
; 1155 : 
; 1156 : 	font->get_pitch(&l_width,&l_height);

	lea	eax, DWORD PTR _l_height$[ebp]
	push	eax
	lea	ecx, DWORD PTR _l_width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+308]
	call	?get_pitch@XFont@@QAEXPAM0@Z		; XFont::get_pitch

; 1157 : 
; 1158 : 	float dxf,dyf;
; 1159 : 
; 1160 : 	dxf=(float)dx;

	fild	DWORD PTR _dx$[ebp]
	fstp	DWORD PTR _dxf$[ebp]

; 1161 : 	dyf=(float)dy;

	fild	DWORD PTR _dy$[ebp]
	fstp	DWORD PTR _dyf$[ebp]

; 1162 : 
; 1163 : 	verts[0].x=((float)x1) - dxf;

	fild	DWORD PTR _x1$[ebp]
	fsub	DWORD PTR _dxf$[ebp]
	fstp	DWORD PTR _verts$[ebp]

; 1164 : 	verts[0].y=(float)y1;

	fild	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR _verts$[ebp+4]

; 1165 : 	verts[0].z=1.0f;

	mov	DWORD PTR _verts$[ebp+8], 1065353216	; 3f800000H

; 1166 : 	verts[0].rhw=1.0f;

	mov	DWORD PTR _verts$[ebp+12], 1065353216	; 3f800000H

; 1167 : 	verts[0].color=0xFFFFFFFF;

	mov	DWORD PTR _verts$[ebp+16], -1

; 1168 : 
; 1169 : 	verts[1].x=((float)(x1+dx)) - dxf;

	mov	eax, DWORD PTR _x1$[ebp]
	add	eax, DWORD PTR _dx$[ebp]
	mov	DWORD PTR -180+[ebp], eax
	fild	DWORD PTR -180+[ebp]
	fsub	DWORD PTR _dxf$[ebp]
	fstp	DWORD PTR _verts$[ebp+28]

; 1170 : 	verts[1].y=(float)y1;

	fild	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR _verts$[ebp+32]

; 1171 : 	verts[1].z=1.0f;

	mov	DWORD PTR _verts$[ebp+36], 1065353216	; 3f800000H

; 1172 : 	verts[1].rhw=1.0f;

	mov	DWORD PTR _verts$[ebp+40], 1065353216	; 3f800000H

; 1173 : 	verts[1].color=0xFFFFFFFF;

	mov	DWORD PTR _verts$[ebp+44], -1

; 1174 : 
; 1175 : 	verts[2].x=((float)(x1+dx)) - dxf;

	mov	ecx, DWORD PTR _x1$[ebp]
	add	ecx, DWORD PTR _dx$[ebp]
	mov	DWORD PTR -184+[ebp], ecx
	fild	DWORD PTR -184+[ebp]
	fsub	DWORD PTR _dxf$[ebp]
	fstp	DWORD PTR _verts$[ebp+56]

; 1176 : 	verts[2].y=(float)(y1+dy);

	mov	edx, DWORD PTR _y1$[ebp]
	add	edx, DWORD PTR _dy$[ebp]
	mov	DWORD PTR -188+[ebp], edx
	fild	DWORD PTR -188+[ebp]
	fstp	DWORD PTR _verts$[ebp+60]

; 1177 : 	verts[2].z=1.0f;

	mov	DWORD PTR _verts$[ebp+64], 1065353216	; 3f800000H

; 1178 : 	verts[2].rhw=1.0f;

	mov	DWORD PTR _verts$[ebp+68], 1065353216	; 3f800000H

; 1179 : 	verts[2].color=0xFFFFFFFF;

	mov	DWORD PTR _verts$[ebp+72], -1

; 1180 : 
; 1181 : 	verts[3].x=((float)x1) - dxf;

	fild	DWORD PTR _x1$[ebp]
	fsub	DWORD PTR _dxf$[ebp]
	fstp	DWORD PTR _verts$[ebp+84]

; 1182 : 	verts[3].y=(float)(y1+dy);

	mov	eax, DWORD PTR _y1$[ebp]
	add	eax, DWORD PTR _dy$[ebp]
	mov	DWORD PTR -192+[ebp], eax
	fild	DWORD PTR -192+[ebp]
	fstp	DWORD PTR _verts$[ebp+88]

; 1183 : 	verts[3].z=1.0f;

	mov	DWORD PTR _verts$[ebp+92], 1065353216	; 3f800000H

; 1184 : 	verts[3].rhw=1.0f;

	mov	DWORD PTR _verts$[ebp+96], 1065353216	; 3f800000H

; 1185 : 	verts[3].color=0xFFFFFFFF;

	mov	DWORD PTR _verts$[ebp+100], -1

; 1186 : 
; 1187 : 	char key;
; 1188 : 
; 1189 : 	/* make room for string */
; 1190 : 	DxVertexT *space=begin_prim(PRIM_TRIANGLELIST,3*2*len);

	mov	ecx, DWORD PTR _len$[ebp]
	imul	ecx, 6
	push	ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z ; VidD3D::begin_prim
	mov	DWORD PTR _space$[ebp], eax

; 1191 : 	U32 tri_count=0;

	mov	DWORD PTR _tri_count$[ebp], 0
$L65974:

; 1192 : 	while(key=*str++)

	mov	edx, DWORD PTR _str$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _key$[ebp], al
	movsx	ecx, BYTE PTR _key$[ebp]
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx
	test	ecx, ecx
	je	$L65975

; 1194 : 		float s,t;
; 1195 : 
; 1196 : 		font->get_letter(key,&s,&t);

	lea	eax, DWORD PTR _t$65977[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$65976[ebp]
	push	ecx
	mov	dl, BYTE PTR _key$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	call	?get_letter@XFont@@QAEXDPAM0@Z		; XFont::get_letter

; 1197 : 		
; 1198 : 		verts[0].x += dxf;

	fld	DWORD PTR _verts$[ebp]
	fadd	DWORD PTR _dxf$[ebp]
	fstp	DWORD PTR _verts$[ebp]

; 1199 : 		verts[0].s = s;

	mov	ecx, DWORD PTR _s$65976[ebp]
	mov	DWORD PTR _verts$[ebp+20], ecx

; 1200 : 		verts[0].t = t;

	mov	edx, DWORD PTR _t$65977[ebp]
	mov	DWORD PTR _verts$[ebp+24], edx

; 1201 : 
; 1202 : 		verts[1].x += dxf;

	fld	DWORD PTR _verts$[ebp+28]
	fadd	DWORD PTR _dxf$[ebp]
	fstp	DWORD PTR _verts$[ebp+28]

; 1203 : 		verts[1].s = s + l_width;

	fld	DWORD PTR _s$65976[ebp]
	fadd	DWORD PTR _l_width$[ebp]
	fstp	DWORD PTR _verts$[ebp+48]

; 1204 : 		verts[1].t = t;

	mov	eax, DWORD PTR _t$65977[ebp]
	mov	DWORD PTR _verts$[ebp+52], eax

; 1205 : 
; 1206 : 		verts[2].x += dxf;

	fld	DWORD PTR _verts$[ebp+56]
	fadd	DWORD PTR _dxf$[ebp]
	fstp	DWORD PTR _verts$[ebp+56]

; 1207 : 		verts[2].s = s + l_width;

	fld	DWORD PTR _s$65976[ebp]
	fadd	DWORD PTR _l_width$[ebp]
	fstp	DWORD PTR _verts$[ebp+76]

; 1208 : 		verts[2].t = t + l_height;

	fld	DWORD PTR _t$65977[ebp]
	fadd	DWORD PTR _l_height$[ebp]
	fstp	DWORD PTR _verts$[ebp+80]

; 1209 : 
; 1210 : 		verts[3].x += dxf;

	fld	DWORD PTR _verts$[ebp+84]
	fadd	DWORD PTR _dxf$[ebp]
	fstp	DWORD PTR _verts$[ebp+84]

; 1211 : 		verts[3].s = s;

	mov	ecx, DWORD PTR _s$65976[ebp]
	mov	DWORD PTR _verts$[ebp+104], ecx

; 1212 : 		verts[3].t = t + l_height;

	fld	DWORD PTR _t$65977[ebp]
	fadd	DWORD PTR _l_height$[ebp]
	fstp	DWORD PTR _verts$[ebp+108]

; 1213 : 
; 1214 : 		/* don't render spaces */
; 1215 : 		if (key!=' ')

	movsx	edx, BYTE PTR _key$[ebp]
	cmp	edx, 32					; 00000020H
	je	$L65978

; 1217 : 			set_vert_adv(space,&verts[0]);

	lea	eax, DWORD PTR _verts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _space$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 1218 : 			set_vert_adv(space,&verts[1]);

	lea	edx, DWORD PTR _verts$[ebp+28]
	push	edx
	lea	eax, DWORD PTR _space$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 1219 : 			set_vert_adv(space,&verts[2]);

	lea	ecx, DWORD PTR _verts$[ebp+56]
	push	ecx
	lea	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 1220 : 
; 1221 : 			set_vert_adv(space,&verts[0]);

	lea	eax, DWORD PTR _verts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _space$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 1222 : 			set_vert_adv(space,&verts[2]);

	lea	edx, DWORD PTR _verts$[ebp+56]
	push	edx
	lea	eax, DWORD PTR _space$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 1223 : 			set_vert_adv(space,&verts[3]);

	lea	ecx, DWORD PTR _verts$[ebp+84]
	push	ecx
	lea	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set_vert_adv@VidD3D@@IAEXAAPAUDxVertexT@@PAU2@@Z ; VidD3D::set_vert_adv

; 1224 : 
; 1225 : 			tri_count+=2;

	mov	eax, DWORD PTR _tri_count$[ebp]
	add	eax, 2
	mov	DWORD PTR _tri_count$[ebp], eax
$L65978:

; 1227 : 	}

	jmp	$L65974
$L65975:

; 1228 : 
; 1229 : 	end_prim(space,tri_count);

	mov	ecx, DWORD PTR _tri_count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _space$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z	; VidD3D::end_prim

; 1230 : 
; 1231 : 	REND_POLY_END();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rend_end_debug@VidD3D@@IAEXXZ		; VidD3D::rend_end_debug

; 1232 : 
; 1233 : 	/* restore for regular rendering */
; 1234 : 	ColorMode(cmode);

	mov	eax, DWORD PTR _cmode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+72]

; 1235 : 	AlphaTestMode(atmode);

	mov	eax, DWORD PTR _atmode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+96]

; 1236 : 	AlphaMode(amode);

	mov	eax, DWORD PTR _amode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+76]

; 1237 : 	BlendMode(bmode);

	mov	eax, DWORD PTR _bmode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 1238 : 	MagFilterMode(fmode);

	mov	eax, DWORD PTR _fmode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+92]
$L65938:

; 1239 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?DrawString@VidD3D@@UAEXHHHHPADEHHH@Z ENDP		; VidD3D::DrawString
_TEXT	ENDS
PUBLIC	?get@XFontLetter@@QAEXPAM0@Z			; XFontLetter::get
;	COMDAT ?get_letter@XFont@@QAEXDPAM0@Z
_TEXT	SEGMENT
_letter$ = 8
_s$ = 12
_t$ = 16
_this$ = -4
?get_letter@XFont@@QAEXDPAM0@Z PROC NEAR		; XFont::get_letter, COMDAT

; 350  : 	void get_letter(char letter,float *s,float *t){letters[letter].get(s,t);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	movsx	edx, BYTE PTR _letter$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+44]
	call	?get@XFontLetter@@QAEXPAM0@Z		; XFontLetter::get
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get_letter@XFont@@QAEXDPAM0@Z ENDP			; XFont::get_letter
_TEXT	ENDS
;	COMDAT ?get@XFontLetter@@QAEXPAM0@Z
_TEXT	SEGMENT
_S$ = 8
_T$ = 12
_this$ = -4
?get@XFontLetter@@QAEXPAM0@Z PROC NEAR			; XFontLetter::get, COMDAT

; 335  : 	void get(float *S,float *T){*S=s;*T=t;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _S$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _T$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?get@XFontLetter@@QAEXPAM0@Z ENDP			; XFontLetter::get
_TEXT	ENDS
;	COMDAT ?get_pitch@XFont@@QAEXPAM0@Z
_TEXT	SEGMENT
_Width$ = 8
_Height$ = 12
_this$ = -4
?get_pitch@XFont@@QAEXPAM0@Z PROC NEAR			; XFont::get_pitch, COMDAT

; 351  : 	void get_pitch(float *Width,float *Height){*Width=width;*Height=height;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _Width$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3116]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _Height$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3120]
	mov	DWORD PTR [eax], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?get_pitch@XFont@@QAEXPAM0@Z ENDP			; XFont::get_pitch
_TEXT	ENDS
PUBLIC	?is_drawable@XFont@@QAEKD@Z			; XFont::is_drawable
PUBLIC	?is_char_drawable@VidD3D@@UAEKD@Z		; VidD3D::is_char_drawable
_TEXT	SEGMENT
_key$ = 8
_this$ = -4
?is_char_drawable@VidD3D@@UAEKD@Z PROC NEAR		; VidD3D::is_char_drawable

; 1242 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1243 : 	return font->is_drawable(key);

	mov	al, BYTE PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+308]
	call	?is_drawable@XFont@@QAEKD@Z		; XFont::is_drawable

; 1244 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?is_char_drawable@VidD3D@@UAEKD@Z ENDP			; VidD3D::is_char_drawable
_TEXT	ENDS
;	COMDAT ?is_drawable@XFont@@QAEKD@Z
_TEXT	SEGMENT
_letter$ = 8
_this$ = -4
?is_drawable@XFont@@QAEKD@Z PROC NEAR			; XFont::is_drawable, COMDAT

; 352  : 	U32 is_drawable(char letter){return letters[letter].drawable;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movsx	eax, BYTE PTR _letter$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax+52]
	mov	esp, ebp
	pop	ebp
	ret	4
?is_drawable@XFont@@QAEKD@Z ENDP			; XFont::is_drawable
_TEXT	ENDS
PUBLIC	?LockScreen@VidD3D@@UAEKW4vidlockscreentype_t@@PAPAGPAH@Z ; VidD3D::LockScreen
_DATA	SEGMENT
	ORG $+1
$SG65994 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG65997 DB	'VidD3D::LockScreen: unable to get surface', 00H
	ORG $+2
$SG66005 DB	'VidD3D::LockScreen: unsupported locking surface', 00H
$SG66009 DB	'VidD3D::LockScreen: unable to lock surface', 00H
_DATA	ENDS
_TEXT	SEGMENT
_lock$ = 8
_this$ = -12
_lock_rect$ = -8
?LockScreen@VidD3D@@UAEKW4vidlockscreentype_t@@PAPAGPAH@Z PROC NEAR ; VidD3D::LockScreen

; 1247 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
$L65989:

; 1248 : 	D_ASSERT(!locked_surf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $L65992
	push	1248					; 000004e0H
	push	OFFSET FLAT:$SG65994
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65992:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65989

; 1249 : 
; 1250 : 	if (dev->GetBackBuffer(0,D3DBACKBUFFER_TYPE_MONO,&locked_surf)!=D3D_OK)

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+64]
	test	eax, eax
	je	SHORT $L65996

; 1251 : 		xxx_throw("VidD3D::LockScreen: unable to get surface");

	mov	ecx, OFFSET FLAT:$SG65997
	call	DWORD PTR __imp_@xxx_throw@4
$L65996:

; 1254 : 	{

	mov	eax, DWORD PTR _lock$[ebp]
	mov	DWORD PTR -16+[ebp], eax
	cmp	DWORD PTR -16+[ebp], 1
	je	SHORT $L66002
	cmp	DWORD PTR -16+[ebp], 3
	je	SHORT $L66003
	jmp	SHORT $L66004
$L66002:

; 1255 : 		case VLS_READBACK:
; 1256 : 			break;

	jmp	SHORT $L65999
$L66003:

; 1257 : 		case VLS_WRITEBACK:
; 1258 : 			break;

	jmp	SHORT $L65999
$L66004:

; 1259 : 		default:
; 1260 : 			xxx_throw("VidD3D::LockScreen: unsupported locking surface");

	mov	ecx, OFFSET FLAT:$SG66005
	call	DWORD PTR __imp_@xxx_throw@4
$L65999:

; 1263 : 	D3DLOCKED_RECT lock_rect;
; 1264 : 
; 1265 : 	if (locked_surf->LockRect(&lock_rect,null,0)!=D3D_OK)

	push	0
	push	0
	lea	ecx, DWORD PTR _lock_rect$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	ecx, DWORD PTR [edx]
	push	eax
	call	DWORD PTR [ecx+36]
	test	eax, eax
	je	SHORT $L66008

; 1266 : 		xxx_throw("VidD3D::LockScreen: unable to lock surface");

	mov	ecx, OFFSET FLAT:$SG66009
	call	DWORD PTR __imp_@xxx_throw@4
$L66008:

; 1267 : 
; 1268 : 	return TRUE;

	mov	eax, 1

; 1269 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?LockScreen@VidD3D@@UAEKW4vidlockscreentype_t@@PAPAGPAH@Z ENDP ; VidD3D::LockScreen
_TEXT	ENDS
PUBLIC	?UnlockScreen@VidD3D@@UAEXXZ			; VidD3D::UnlockScreen
_DATA	SEGMENT
	ORG $+1
$SG66016 DB	'VidD3D::UnlockScreen: unable to unlock rect', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -4
?UnlockScreen@VidD3D@@UAEXXZ PROC NEAR			; VidD3D::UnlockScreen

; 1272 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1273 : 	if (locked_surf->UnlockRect()!=D3D_OK)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+40]
	test	eax, eax
	je	SHORT $L66015

; 1274 : 		xxx_throw("VidD3D::UnlockScreen: unable to unlock rect");

	mov	ecx, OFFSET FLAT:$SG66016
	call	DWORD PTR __imp_@xxx_throw@4
$L66015:

; 1275 : 	locked_surf->Release();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+8]

; 1276 : 	locked_surf=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 1277 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UnlockScreen@VidD3D@@UAEXXZ ENDP			; VidD3D::UnlockScreen
_TEXT	ENDS
PUBLIC	?BeginScene@VidD3D@@UAEXXZ			; VidD3D::BeginScene
EXTRN	?BeginNewFrame@VManager@@QAEXXZ:NEAR		; VManager::BeginNewFrame
_DATA	SEGMENT
$SG66023 DB	'VidD3D::BeginScene failed', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -4
?BeginScene@VidD3D@@UAEXXZ PROC NEAR			; VidD3D::BeginScene

; 1280 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1281 : 	if (dev->BeginScene()!=D3D_OK)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+136]
	test	eax, eax
	je	SHORT $L66022

; 1282 : 		xxx_fatal("VidD3D::BeginScene failed");

	mov	ecx, OFFSET FLAT:$SG66023
	call	DWORD PTR __imp_@xxx_fatal@4
$L66022:

; 1283 : 
; 1284 : 	vid_state.in_scene=TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1285 : 	vbuffers->BeginNewFrame();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?BeginNewFrame@VManager@@QAEXXZ		; VManager::BeginNewFrame

; 1286 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BeginScene@VidD3D@@UAEXXZ ENDP				; VidD3D::BeginScene
_TEXT	ENDS
PUBLIC	?EndScene@VidD3D@@UAEXXZ			; VidD3D::EndScene
_DATA	SEGMENT
	ORG $+2
$SG66033 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG66036 DB	'VidD3D::EndScene failed', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -4
?EndScene@VidD3D@@UAEXXZ PROC NEAR			; VidD3D::EndScene

; 1289 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
$L66028:

; 1290 : 	D_ASSERT(vid_state.in_scene);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 2
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L66031
	push	1290					; 0000050aH
	push	OFFSET FLAT:$SG66033
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L66031:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L66028

; 1291 : 	vbuffers->flush();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 1292 : 
; 1293 : 	//VidTexD3D *old_tex=active_tex;
; 1294 : 
; 1295 : 	//TexActivate(GetBlankTex(),VTA_NORMAL);
; 1296 : 	//vbuffers->EndScene();
; 1297 : 	//TexActivate(old_tex,VTA_NORMAL);
; 1298 : 
; 1299 : 	if (dev->EndScene()!=D3D_OK)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+140]
	test	eax, eax
	je	SHORT $L66035

; 1300 : 		xxx_fatal("VidD3D::EndScene failed");

	mov	ecx, OFFSET FLAT:$SG66036
	call	DWORD PTR __imp_@xxx_fatal@4
$L66035:

; 1301 : 
; 1302 : #if 0
; 1303 : 	if (dev->GetBackBuffer(0,D3DBACKBUFFER_TYPE_MONO,&locked_surf)!=D3D_OK)
; 1304 : 		xxx_throw("VidD3D::LockScreen: unable to get surface");
; 1305 : 	
; 1306 : 	D3DLOCKED_RECT lock_rect;
; 1307 : 	if (locked_surf->LockRect(&lock_rect,null,0)!=D3D_OK)
; 1308 : 		xxx_throw("VidD3D::LockScreen: unable to lock surface");
; 1309 : 
; 1310 : 	if (locked_surf->UnlockRect()!=D3D_OK)
; 1311 : 		xxx_throw("VidD3D::UnlockScreen: unable to unlock rect");
; 1312 : 
; 1313 : 	locked_surf->Release();
; 1314 : 	locked_surf=null;
; 1315 : #endif
; 1316 : 	vid_state.in_scene=FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1317 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EndScene@VidD3D@@UAEXXZ ENDP				; VidD3D::EndScene
_TEXT	ENDS
PUBLIC	?ClipGood@VidD3D@@UAEXXZ			; VidD3D::ClipGood
_TEXT	SEGMENT
_this$ = -4
?ClipGood@VidD3D@@UAEXXZ PROC NEAR			; VidD3D::ClipGood

; 1320 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1321 : 	if (!vid_state.clip_good)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shr	ecx, 23					; 00000017H
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L66041

; 1322 : 		vbuffers->flush();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?flush@VManager@@QAEXXZ			; VManager::flush
$L66041:

; 1323 : 
; 1324 : 	vid_state.clip_good=TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8388608				; 00800000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1325 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClipGood@VidD3D@@UAEXXZ ENDP				; VidD3D::ClipGood
_TEXT	ENDS
PUBLIC	?ClipBad@VidD3D@@UAEXXZ				; VidD3D::ClipBad
_TEXT	SEGMENT
_this$ = -4
?ClipBad@VidD3D@@UAEXXZ PROC NEAR			; VidD3D::ClipBad

; 1328 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1329 : 	vid_state.clip_good=FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8388609				; ff7fffffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1330 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClipBad@VidD3D@@UAEXXZ ENDP				; VidD3D::ClipBad
_TEXT	ENDS
PUBLIC	?BeginLines@VidD3D@@UAEXK@Z			; VidD3D::BeginLines
_DATA	SEGMENT
$SG66055 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_guess_num$ = 8
_this$ = -4
?BeginLines@VidD3D@@UAEXK@Z PROC NEAR			; VidD3D::BeginLines

; 1333 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
$L66050:

; 1334 : 	D_ASSERT(!vid_state.in_prim);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L66053
	push	1334					; 00000536H
	push	OFFSET FLAT:$SG66055
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L66053:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L66050

; 1335 : 	vid_state.in_prim=TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 	prim_guess=guess_num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _guess_num$[ebp]
	mov	DWORD PTR [eax+340], ecx

; 1337 : 	prim_space=begin_prim(PRIM_LINELIST,guess_num*2);

	mov	edx, DWORD PTR _guess_num$[ebp]
	shl	edx, 1
	push	edx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin_prim@VidD3D@@IAEPAUDxVertexT@@KK@Z ; VidD3D::begin_prim
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+348], eax

; 1338 : 	prim_start=prim_space;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+348]
	mov	DWORD PTR [edx+352], ecx

; 1339 : 	prim_count=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+344], 0

; 1340 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?BeginLines@VidD3D@@UAEXK@Z ENDP			; VidD3D::BeginLines
_TEXT	ENDS
PUBLIC	?EndLines@VidD3D@@UAEXXZ			; VidD3D::EndLines
_DATA	SEGMENT
	ORG $+1
$SG66068 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
	ORG $+1
$SG66075 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.c'
	DB	'pp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -4
?EndLines@VidD3D@@UAEXXZ PROC NEAR			; VidD3D::EndLines

; 1343 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1344 : 	if (!vid_state.in_prim)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L66060

; 1345 : 		return;

	jmp	$L66059
$L66060:

; 1346 : 	D_ASSERT((I32)(prim_space-prim_start)<=(I32)(prim_guess*2));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+348]
	sub	ecx, DWORD PTR [eax+352]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+340]
	shl	ecx, 1
	cmp	eax, ecx
	jle	SHORT $L66066
	push	1346					; 00000542H
	push	OFFSET FLAT:$SG66068
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L66066:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L66060
$L66063:

; 1347 : 	D_ASSERT((prim_count*2)==(U32)(prim_space-prim_start));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+344]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+348]
	sub	edx, DWORD PTR [eax+352]
	mov	eax, edx
	cdq
	mov	esi, 28					; 0000001cH
	idiv	esi
	cmp	ecx, eax
	je	SHORT $L66073
	push	1347					; 00000543H
	push	OFFSET FLAT:$SG66075
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L66073:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L66063

; 1348 : 	end_prim(prim_space,prim_count);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+348]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end_prim@VidD3D@@IAEXPAUDxVertexT@@K@Z	; VidD3D::end_prim

; 1349 : 	prim_space=null;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+348], 0

; 1350 : 	vid_state.in_prim=FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$L66059:

; 1351 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?EndLines@VidD3D@@UAEXXZ ENDP				; VidD3D::EndLines
_TEXT	ENDS
PUBLIC	__real@4@c0008000000000000000
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	?SetHooptiFrustum@VidD3D@@UAEXMMMM@Z		; VidD3D::SetHooptiFrustum
EXTRN	_D3DXMatrixPerspectiveLH@20:NEAR
;	COMDAT __real@4@c0008000000000000000
; File D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vidif.cpp
CONST	SEGMENT
__real@4@c0008000000000000000 DD 0c0000000r	; -2
CONST	ENDS
_TEXT	SEGMENT
_znear$ = 16
_zfar$ = 20
_this$ = -68
_matrix$ = -64
?SetHooptiFrustum@VidD3D@@UAEXMMMM@Z PROC NEAR		; VidD3D::SetHooptiFrustum

; 1354 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1355 : #if 0
; 1356 : 	float xmax=tanf(fov_angle)*near;
; 1357 : 	float ymax=xmax/xy_ratio;
; 1358 : #endif
; 1359 : 
; 1360 : 	D3DXMATRIX matrix;

	lea	ecx, DWORD PTR _matrix$[ebp]
	call	??0D3DXMATRIX@@QAE@XZ			; D3DXMATRIX::D3DXMATRIX

; 1361 : 
; 1362 : 	matrix.m[2][2]=(zfar+znear) / (zfar-znear);

	fld	DWORD PTR _zfar$[ebp]
	fadd	DWORD PTR _znear$[ebp]
	fld	DWORD PTR _zfar$[ebp]
	fsub	DWORD PTR _znear$[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _matrix$[ebp+40]

; 1363 : 	matrix.m[2][3]=(-2*zfar*znear) / (zfar - znear);

	fld	DWORD PTR __real@4@c0008000000000000000
	fmul	DWORD PTR _zfar$[ebp]
	fmul	DWORD PTR _znear$[ebp]
	fld	DWORD PTR _zfar$[ebp]
	fsub	DWORD PTR _znear$[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _matrix$[ebp+44]

; 1364 : 
; 1365 : 	matrix.m[0][0]=1.0f;matrix.m[0][1]=0.0f;matrix.m[0][2]=0.0f;matrix.m[0][3]=0.0f;

	mov	DWORD PTR _matrix$[ebp], 1065353216	; 3f800000H
	mov	DWORD PTR _matrix$[ebp+4], 0
	mov	DWORD PTR _matrix$[ebp+8], 0
	mov	DWORD PTR _matrix$[ebp+12], 0

; 1366 : 	matrix.m[1][0]=0.0f;matrix.m[1][1]=1.0f;matrix.m[1][2]=0.0f;matrix.m[1][3]=0.0f;

	mov	DWORD PTR _matrix$[ebp+16], 0
	mov	DWORD PTR _matrix$[ebp+20], 1065353216	; 3f800000H
	mov	DWORD PTR _matrix$[ebp+24], 0
	mov	DWORD PTR _matrix$[ebp+28], 0

; 1367 : 	matrix.m[2][0]=0.0f;matrix.m[2][1]=0.0f;

	mov	DWORD PTR _matrix$[ebp+32], 0
	mov	DWORD PTR _matrix$[ebp+36], 0

; 1368 : 	matrix.m[3][0]=0.0f;matrix.m[3][1]=0.0f;matrix.m[2][2]=0.0f;matrix.m[3][3]=1.0f;

	mov	DWORD PTR _matrix$[ebp+48], 0
	mov	DWORD PTR _matrix$[ebp+52], 0
	mov	DWORD PTR _matrix$[ebp+40], 0
	mov	DWORD PTR _matrix$[ebp+60], 1065353216	; 3f800000H

; 1369 : 
; 1370 : 	D3DXMatrixPerspectiveLH(&matrix,1.0f,1.0f,0.5f,1024.0f);

	push	1149239296				; 44800000H
	push	1056964608				; 3f000000H
	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_D3DXMatrixPerspectiveLH@20

; 1371 : 
; 1372 : 	dev->SetTransform(D3DTS_PROJECTION,&matrix);

	lea	ecx, DWORD PTR _matrix$[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR [edx]
	push	eax
	call	DWORD PTR [ecx+148]

; 1373 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetHooptiFrustum@VidD3D@@UAEXMMMM@Z ENDP		; VidD3D::SetHooptiFrustum
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0D3DXMATRIX@@QAE@XZ PROC NEAR				; D3DXMATRIX::D3DXMATRIX, COMDAT

; 184  :     D3DXMATRIX() {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
END
