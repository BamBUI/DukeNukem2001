	TITLE	D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vbuffer.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DD@BIGB@D?3?2Games?2duke_nukem_forever?2Hack@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@MBIJ@Cannot?5init?5CPrintfT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@CDMH@Unable?5to?5lock?5vertex?5buffer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DK@KCID@D?3?2Games?2duke_nukem_forever?2Hack@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@NEML@Unable?5to?5unlock?5vertex?5buffer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@HNDD@Already?5in?5primitive?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DDMK@Not?5in?5primitive?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GDIC@bad?5primitive?5type?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@MEJC@VManager?3?3end_prim?3?5DrawPrimitiv@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DC@MINH@D?3?2Games?2duke_nukem_forever?2Hack@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XListState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XListState@@QAE@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0XChainState@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0MemStats@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_locked@XMutex@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_d_assert@@YAXPBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FindState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1VidTex@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GVidTex@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1VidView@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GVidView@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1VidIf@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetColor@VidIf@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlatColor@VidIf@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BeginScene@VidIf@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndScene@VidIf@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Diags@VidIf@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BeginLines@VidIf@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndLines@VidIf@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GVidIf@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR2@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXMATRIX@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXPLANE@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PrimD3D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?realloc@PrimBuffer@@AAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reset@PrimBuffer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PrimBuffer@@QAE@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VBState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@VBuffer@@QAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@VBuffer@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_room@VBuffer@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is_finished@VBuffer@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0VBManState@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckRoom@VManager@@IAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin_prim@VManager@@QAEPAUDxVertexT@@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end_prim@VManager@@QAEXPAUDxVertexT@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPrimBuffer@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PrimBuffer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set@XFontLetter@@QAEXMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get@XFontLetter@@QAEXPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set_drawable@XFontLetter@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRingChain@VVBuffer@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$autoptr@VXImage@@@@QAEPAVXImage@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XChain@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XChain@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXStatistic@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_list@?$XList@VXStatistic@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add_head@?$XList@VXStatistic@@@@QAEPAU_XPos@@PAVXStatistic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove_head@?$XList@VXStatistic@@@@QAEPAVXStatistic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcBase@VCStrObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRcPtr@VCPathObj@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VXFindLevel@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XRingChain@VVBuffer@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert_after@?$XRingChain@VVBuffer@@@@QAEPAVVBuffer@@PAV2@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$XList@VVidTexD3D@@@@QAE@KK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$XList@VVidTexD3D@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSysObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GXFindLevel@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GVBuffer@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?new_node@?$XList@VXStatistic@@@@IAEPAUXNode@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXStatistic@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VXFindLevel@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free_nodes@?$XList@VVidTexD3D@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcBase@VCStrObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DelRef@?$XRcPtr@VCPathObj@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStrObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPathObj@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7VidTex@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7VidIf@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMemMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7XMutex@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7VidView@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??2@YAPAXI@Z					; operator new
EXTRN	__imp_@xmalloc@4:NEAR
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_size$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 129  : __inline void *operator new(size_t size){return xmalloc(size);}

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _size$[ebp]
	call	DWORD PTR __imp_@xmalloc@4
	pop	ebp
	ret	0
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX@Z					; operator delete
EXTRN	__imp_@xfree@4:NEAR
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 130  : __inline void operator delete(void *ptr){xfree(ptr);}

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _ptr$[ebp]
	call	DWORD PTR __imp_@xfree@4
	pop	ebp
	ret	0
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?calc_vsize@@YAKK@Z				; calc_vsize
EXTRN	__imp_@xxx_fatal@4:NEAR
_DATA	SEGMENT
$SG65200 DB	'calc_vsize: Unhandled vertex format type', 00H
_DATA	ENDS
_TEXT	SEGMENT
_fvf_flags$ = 8
_size$ = -4
?calc_vsize@@YAKK@Z PROC NEAR				; calc_vsize

; 6    : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7    : 	if (fvf_flags & D3DFVF_PSIZE)

	mov	eax, DWORD PTR _fvf_flags$[ebp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $L65199

; 8    : 		xxx_fatal("calc_vsize: Unhandled vertex format type");

	mov	ecx, OFFSET FLAT:$SG65200
	call	DWORD PTR __imp_@xxx_fatal@4
$L65199:

; 9    : 
; 10   : 	U32 size=0;

	mov	DWORD PTR _size$[ebp], 0

; 11   : 	if (fvf_flags & D3DFVF_DIFFUSE)

	mov	ecx, DWORD PTR _fvf_flags$[ebp]
	and	ecx, 64					; 00000040H
	test	ecx, ecx
	je	SHORT $L65202

; 12   : 		size+=1;

	mov	edx, DWORD PTR _size$[ebp]
	add	edx, 1
	mov	DWORD PTR _size$[ebp], edx
$L65202:

; 13   : 	if (fvf_flags & D3DFVF_NORMAL)

	mov	eax, DWORD PTR _fvf_flags$[ebp]
	and	eax, 16					; 00000010H
	test	eax, eax
	je	SHORT $L65203

; 14   : 		size+=3;

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 3
	mov	DWORD PTR _size$[ebp], ecx
$L65203:

; 15   : 	if (fvf_flags & D3DFVF_SPECULAR)

	mov	edx, DWORD PTR _fvf_flags$[ebp]
	and	edx, 128				; 00000080H
	test	edx, edx
	je	SHORT $L65204

; 16   : 		size+=1;

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 1
	mov	DWORD PTR _size$[ebp], eax
$L65204:

; 17   : 	if (fvf_flags & D3DFVF_XYZ)

	mov	ecx, DWORD PTR _fvf_flags$[ebp]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L65205

; 18   : 		size+=3;

	mov	edx, DWORD PTR _size$[ebp]
	add	edx, 3
	mov	DWORD PTR _size$[ebp], edx
$L65205:

; 19   : 	if (fvf_flags & D3DFVF_XYZRHW)

	mov	eax, DWORD PTR _fvf_flags$[ebp]
	and	eax, 4
	test	eax, eax
	je	SHORT $L65206

; 20   : 		size+=4;

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 4
	mov	DWORD PTR _size$[ebp], ecx
$L65206:

; 21   : 	/* add vertex blending weights */
; 22   : 	if ((fvf_flags & D3DFVF_XYZB1)==D3DFVF_XYZB1)

	mov	edx, DWORD PTR _fvf_flags$[ebp]
	and	edx, 6
	cmp	edx, 6
	jne	SHORT $L65207

; 23   : 		size+=1;

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 24   : 	else if ((fvf_flags & D3DFVF_XYZB2)==D3DFVF_XYZB2)

	jmp	SHORT $L65215
$L65207:
	mov	ecx, DWORD PTR _fvf_flags$[ebp]
	and	ecx, 8
	cmp	ecx, 8
	jne	SHORT $L65209

; 25   : 		size+=2;

	mov	edx, DWORD PTR _size$[ebp]
	add	edx, 2
	mov	DWORD PTR _size$[ebp], edx

; 26   : 	else if ((fvf_flags & D3DFVF_XYZB3)==D3DFVF_XYZB3)

	jmp	SHORT $L65215
$L65209:
	mov	eax, DWORD PTR _fvf_flags$[ebp]
	and	eax, 10					; 0000000aH
	cmp	eax, 10					; 0000000aH
	jne	SHORT $L65211

; 27   : 		size+=3;

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 3
	mov	DWORD PTR _size$[ebp], ecx

; 28   : 	else if ((fvf_flags & D3DFVF_XYZB4)==D3DFVF_XYZB4)

	jmp	SHORT $L65215
$L65211:
	mov	edx, DWORD PTR _fvf_flags$[ebp]
	and	edx, 12					; 0000000cH
	cmp	edx, 12					; 0000000cH
	jne	SHORT $L65213

; 29   : 		size+=4;

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 4
	mov	DWORD PTR _size$[ebp], eax

; 30   : 	else if ((fvf_flags & D3DFVF_XYZB5)==D3DFVF_XYZB5)

	jmp	SHORT $L65215
$L65213:
	mov	ecx, DWORD PTR _fvf_flags$[ebp]
	and	ecx, 14					; 0000000eH
	cmp	ecx, 14					; 0000000eH
	jne	SHORT $L65215

; 31   : 		size+=5;

	mov	edx, DWORD PTR _size$[ebp]
	add	edx, 5
	mov	DWORD PTR _size$[ebp], edx
$L65215:

; 32   : 	/* add texture coordinates */
; 33   : 	size+=(fvf_flags & 0xF00)>>7;

	mov	eax, DWORD PTR _fvf_flags$[ebp]
	and	eax, 3840				; 00000f00H
	shr	eax, 7
	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, eax
	mov	DWORD PTR _size$[ebp], ecx

; 34   : 
; 35   : 	return size;

	mov	eax, DWORD PTR _size$[ebp]

; 36   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?calc_vsize@@YAKK@Z ENDP				; calc_vsize
_TEXT	ENDS
PUBLIC	??0VBState@@QAE@XZ				; VBState::VBState
PUBLIC	??0VBuffer@@QAE@PAUIDirect3DDevice8@@KK@Z	; VBuffer::VBuffer
PUBLIC	?_d_assert@@YAXPBDK@Z				; _d_assert
EXTRN	__imp_??0autochar@@QAE@XZ:NEAR
EXTRN	__imp_??4autochar@@QAEAAV0@PAD@Z:NEAR
_DATA	SEGMENT
	ORG $+3
$SG65227 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vbuffer'
	DB	'.cpp', 00H
	ORG $+3
$SG65233 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vbuffer'
	DB	'.cpp', 00H
	ORG $+3
$SG65237 DB	'Unable to create vertex buffer', 00H
_DATA	ENDS
_TEXT	SEGMENT
_Dev$ = 8
_fvf_flags$ = 12
_Count$ = 16
_this$ = -4
??0VBuffer@@QAE@PAUIDirect3DDevice8@@KK@Z PROC NEAR	; VBuffer::VBuffer

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Dev$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0VBState@@QAE@XZ			; VBState::VBState
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Count$[ebp]
	mov	DWORD PTR [eax+40], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _fvf_flags$[ebp]
	mov	DWORD PTR [edx+44], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	DWORD PTR __imp_??0autochar@@QAE@XZ
$L65222:

; 40   : 	D_ASSERT(dev);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $L65225
	push	40					; 00000028H
	push	OFFSET FLAT:$SG65227
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65225:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L65222
$L65224:

; 41   : 	D_ASSERT(count<32000);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 32000		; 00007d00H
	jb	SHORT $L65231
	push	41					; 00000029H
	push	OFFSET FLAT:$SG65233
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65231:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L65224

; 42   : 
; 43   : 	if (count>32000)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+40], 32000		; 00007d00H
	jbe	SHORT $L65234

; 44   : 		count=32000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 32000		; 00007d00H
$L65234:

; 45   : 	
; 46   : 	state.vsize=calc_vsize(fvf_flags);

	mov	ecx, DWORD PTR _fvf_flags$[ebp]
	push	ecx
	call	?calc_vsize@@YAKK@Z			; calc_vsize
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	mov	edx, DWORD PTR -8+[ebp]
	and	edx, 31					; 0000001fH
	shl	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	cl, 7
	or	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 47   : 	size=count*state.vsize*4;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 3
	and	ecx, 31					; 0000001fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	imul	eax, ecx
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 48   : #if 0
; 49   : 	if (dev->CreateVertexBuffer(size+512,D3DUSAGE_WRITEONLY|D3DUSAGE_DYNAMIC,fvf,D3DPOOL_DEFAULT,&vbuffer)!=D3D_OK)
; 50   : 		xxx_fatal("Unable to create vertex buffer");
; 51   : #else
; 52   : 	if (dev->CreateVertexBuffer(size+512,D3DUSAGE_DYNAMIC,fvf,D3DPOOL_DEFAULT,&vbuffer)!=D3D_OK)

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	push	512					; 00000200H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 512				; 00000200H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+92]
	test	eax, eax
	je	SHORT $L65236

; 53   : 		xxx_fatal("Unable to create vertex buffer");

	mov	ecx, OFFSET FLAT:$SG65237
	call	DWORD PTR __imp_@xxx_fatal@4
$L65236:

; 54   : #endif
; 55   : 
; 56   : #ifdef SHADOW
; 57   : 	shadow=(char *)xmalloc(size);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	DWORD PTR __imp_@xmalloc@4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	DWORD PTR __imp_??4autochar@@QAEAAV0@PAD@Z

; 58   : #endif
; 59   : 	state.begin=TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	or	al, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 60   : 
; 61   : 	lock_end=cur_off=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 62   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0VBuffer@@QAE@PAUIDirect3DDevice8@@KK@Z ENDP		; VBuffer::VBuffer
_TEXT	ENDS
EXTRN	__imp_?_global@@3PAVXGlobal@@A:DWORD
EXTRN	__imp_?assert@XGlobal@@QAEXPBDK@Z:NEAR
;	COMDAT ?_d_assert@@YAXPBDK@Z
_TEXT	SEGMENT
_file$ = 8
_line$ = 12
?_d_assert@@YAXPBDK@Z PROC NEAR				; _d_assert, COMDAT

; 1483 : {

	push	ebp
	mov	ebp, esp

; 1484 : 	_global->assert(file,line);

	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp_?_global@@3PAVXGlobal@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?assert@XGlobal@@QAEXPBDK@Z

; 1485 : }

	pop	ebp
	ret	0
?_d_assert@@YAXPBDK@Z ENDP				; _d_assert
_TEXT	ENDS
;	COMDAT ??0VBState@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0VBState@@QAE@XZ PROC NEAR				; VBState::VBState, COMDAT

; 115  : 	VBState(void) : has_lock(0),is_finished(0),vsize(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	cl, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VBState@@QAE@XZ ENDP					; VBState::VBState
_TEXT	ENDS
PUBLIC	??1VBuffer@@QAE@XZ				; VBuffer::~VBuffer
EXTRN	__imp_??1autochar@@QAE@XZ:NEAR
_TEXT	SEGMENT
_this$ = -4
??1VBuffer@@QAE@XZ PROC NEAR				; VBuffer::~VBuffer

; 65   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	vbuffer->Release();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+8]

; 67   : 	
; 68   : 	vbuffer=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 69   : 	count=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 70   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	DWORD PTR __imp_??1autochar@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1VBuffer@@QAE@XZ ENDP					; VBuffer::~VBuffer
_TEXT	ENDS
PUBLIC	?finished@VBuffer@@QAEXXZ			; VBuffer::finished
_TEXT	SEGMENT
_this$ = -4
?finished@VBuffer@@QAEXXZ PROC NEAR			; VBuffer::finished

; 74   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 	state.is_finished=TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?finished@VBuffer@@QAEXXZ ENDP				; VBuffer::finished
_TEXT	ENDS
PUBLIC	?begin_frame@VBuffer@@QAEXXZ			; VBuffer::begin_frame
EXTRN	__imp_?get_ptr@autochar@@QAEPAXXZ:NEAR
_TEXT	SEGMENT
_this$ = -4
?begin_frame@VBuffer@@QAEXXZ PROC NEAR			; VBuffer::begin_frame

; 79   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 	state.is_finished=FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 81   : 	state.begin=TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 82   : 	lock_end=cur_off=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 83   : #ifdef SHADOW
; 84   : 	scur32=(U32 *)shadow.get_ptr();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	DWORD PTR __imp_?get_ptr@autochar@@QAEPAXXZ
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], eax

; 85   : #endif
; 86   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?begin_frame@VBuffer@@QAEXXZ ENDP			; VBuffer::begin_frame
_TEXT	ENDS
PUBLIC	?select@VBuffer@@QAEXXZ				; VBuffer::select
_DATA	SEGMENT
	ORG $+1
$SG65258 DB	'Unable to set stream source', 00H
$SG65261 DB	'Unable to set stream source', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -4
?select@VBuffer@@QAEXXZ PROC NEAR			; VBuffer::select

; 89   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 	/* NOTE: Order may be important */
; 91   : 	if (dev->SetStreamSource(0,vbuffer,state.vsize*4)!=D3D_OK)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 3
	and	ecx, 31					; 0000001fH
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+332]
	test	eax, eax
	je	SHORT $L65257

; 92   : 		xxx_fatal("Unable to set stream source");

	mov	ecx, OFFSET FLAT:$SG65258
	call	DWORD PTR __imp_@xxx_fatal@4
$L65257:

; 93   : 	if (dev->SetVertexShader(fvf)!=D3D_OK)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+304]
	test	eax, eax
	je	SHORT $L65260

; 94   : 		xxx_fatal("Unable to set stream source");

	mov	ecx, OFFSET FLAT:$SG65261
	call	DWORD PTR __imp_@xxx_fatal@4
$L65260:

; 95   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?select@VBuffer@@QAEXXZ ENDP				; VBuffer::select
_TEXT	ENDS
PUBLIC	??0PrimD3D@@QAE@XZ				; PrimD3D::PrimD3D
PUBLIC	??0PrimBuffer@@QAE@KK@Z				; PrimBuffer::PrimBuffer
PUBLIC	?get_room@VBuffer@@QAEJXZ			; VBuffer::get_room
PUBLIC	??0VBManState@@QAE@XZ				; VBManState::VBManState
PUBLIC	??0?$XRingChain@VVBuffer@@@@QAE@XZ		; XRingChain<VBuffer>::XRingChain<VBuffer>
PUBLIC	?insert_after@?$XRingChain@VVBuffer@@@@QAEPAVVBuffer@@PAV2@0@Z ; XRingChain<VBuffer>::insert_after
PUBLIC	??0VManager@@QAE@PAVVidD3D@@PAUIDirect3DDevice8@@KKK@Z ; VManager::VManager
EXTRN	__imp_??2MemGrow@@SAPAXI@Z:NEAR
_DATA	SEGMENT
$SG65275 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vbuffer'
	DB	'.cpp', 00H
	ORG $+3
$SG65281 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vbuffer'
	DB	'.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
$T65820 = -12
$T65823 = -16
$T65826 = -20
_Vid$ = 8
_Dev$ = 12
_num_buffers$ = 16
_count$ = 20
_fvf_flags$ = 24
_this$ = -24
_obj$ = -8
_vbuffer_room$ = -4
??0VManager@@QAE@PAVVidD3D@@PAUIDirect3DDevice8@@KKK@Z PROC NEAR ; VManager::VManager

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$XRingChain@VVBuffer@@@@QAE@XZ	; XRingChain<VBuffer>::XRingChain<VBuffer>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Dev$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Vid$[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _fvf_flags$[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0PrimD3D@@QAE@XZ			; PrimD3D::PrimD3D
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0VBManState@@QAE@XZ			; VBManState::VBManState
$L65270:

; 99   : 	D_ASSERT(vid);D_ASSERT(dev);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $L65273
	push	99					; 00000063H
	push	OFFSET FLAT:$SG65275
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65273:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L65270
$L65272:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $L65279
	push	99					; 00000063H
	push	OFFSET FLAT:$SG65281
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65279:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L65272

; 100  : 
; 101  : 	VBuffer *obj=new VBuffer(dev,fvf,def_count);

	push	56					; 00000038H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T65820[ebp], eax
	cmp	DWORD PTR $T65820[ebp], 0
	je	SHORT $L65821
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR $T65820[ebp]
	call	??0VBuffer@@QAE@PAUIDirect3DDevice8@@KK@Z ; VBuffer::VBuffer
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L65822
$L65821:
	mov	DWORD PTR -28+[ebp], 0
$L65822:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR _obj$[ebp], eax

; 102  : 	insert_after(null,obj);

	mov	ecx, DWORD PTR _obj$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert_after@?$XRingChain@VVBuffer@@@@QAEPAVVBuffer@@PAV2@0@Z ; XRingChain<VBuffer>::insert_after

; 103  : 	obj->select();

	mov	ecx, DWORD PTR _obj$[ebp]
	call	?select@VBuffer@@QAEXXZ			; VBuffer::select

; 104  : 	vindex=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
$L65286:

; 105  : 
; 106  : 	while(((I32)(num_buffers-=1))>0)

	mov	eax, DWORD PTR _num_buffers$[ebp]
	sub	eax, 1
	mov	DWORD PTR _num_buffers$[ebp], eax
	cmp	DWORD PTR _num_buffers$[ebp], 0
	jle	SHORT $L65287

; 108  : 		obj=new VBuffer(dev,fvf,def_count);

	push	56					; 00000038H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T65823[ebp], eax
	cmp	DWORD PTR $T65823[ebp], 0
	je	SHORT $L65824
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR $T65823[ebp]
	call	??0VBuffer@@QAE@PAUIDirect3DDevice8@@KK@Z ; VBuffer::VBuffer
	mov	DWORD PTR -32+[ebp], eax
	jmp	SHORT $L65825
$L65824:
	mov	DWORD PTR -32+[ebp], 0
$L65825:
	mov	ecx, DWORD PTR -32+[ebp]
	mov	DWORD PTR _obj$[ebp], ecx

; 109  : 		insert_after(cur,obj);

	mov	edx, DWORD PTR _obj$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert_after@?$XRingChain@VVBuffer@@@@QAEPAVVBuffer@@PAV2@0@Z ; XRingChain<VBuffer>::insert_after

; 110  : 	}

	jmp	SHORT $L65286
$L65287:

; 111  : 
; 112  : 	prims=new PrimBuffer;

	push	24					; 00000018H
	call	DWORD PTR __imp_??2MemGrow@@SAPAXI@Z
	add	esp, 4
	mov	DWORD PTR $T65826[ebp], eax
	cmp	DWORD PTR $T65826[ebp], 0
	je	SHORT $L65827
	push	1024					; 00000400H
	push	2048					; 00000800H
	mov	ecx, DWORD PTR $T65826[ebp]
	call	??0PrimBuffer@@QAE@KK@Z			; PrimBuffer::PrimBuffer
	mov	DWORD PTR -36+[ebp], eax
	jmp	SHORT $L65828
$L65827:
	mov	DWORD PTR -36+[ebp], 0
$L65828:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR -36+[ebp]
	mov	DWORD PTR [edx+16], eax

; 113  : 	
; 114  : 	U32 vbuffer_room=obj->get_room();

	mov	ecx, DWORD PTR _obj$[ebp]
	call	?get_room@VBuffer@@QAEJXZ		; VBuffer::get_room
	mov	DWORD PTR _vbuffer_room$[ebp], eax

; 115  : 	room=vbuffer_room;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vbuffer_room$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 116  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0VManager@@QAE@PAVVidD3D@@PAUIDirect3DDevice8@@KKK@Z ENDP ; VManager::VManager
_TEXT	ENDS
;	COMDAT ??0PrimD3D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0PrimD3D@@QAE@XZ PROC NEAR				; PrimD3D::PrimD3D, COMDAT

; 43   : 	PrimD3D(void) : type(0),count(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+2], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0PrimD3D@@QAE@XZ ENDP					; PrimD3D::PrimD3D
_TEXT	ENDS
PUBLIC	?reset@PrimBuffer@@QAEXXZ			; PrimBuffer::reset
EXTRN	__imp_??0MemGrow@@QAE@K@Z:NEAR
;	COMDAT ??0PrimBuffer@@QAE@KK@Z
_TEXT	SEGMENT
_size$ = 8
_IncSize$ = 12
_this$ = -4
??0PrimBuffer@@QAE@KK@Z PROC NEAR			; PrimBuffer::PrimBuffer, COMDAT

; 75   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 63					; 0000003fH
	and	al, -64					; ffffffc0H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0MemGrow@@QAE@K@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _IncSize$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 76   : 		reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@PrimBuffer@@QAEXXZ		; PrimBuffer::reset

; 77   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0PrimBuffer@@QAE@KK@Z ENDP				; PrimBuffer::PrimBuffer
_TEXT	ENDS
;	COMDAT ?reset@PrimBuffer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?reset@PrimBuffer@@QAEXXZ PROC NEAR			; PrimBuffer::reset, COMDAT

; 67   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 		cur=base;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx

; 69   : 		if (base)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L64291

; 70   : 			end=cur+size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], edx
$L64291:

; 71   : 		prim=(PrimD3D *)base;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 72   : 		prim->type=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	WORD PTR [eax], 0

; 73   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?reset@PrimBuffer@@QAEXXZ ENDP				; PrimBuffer::reset
_TEXT	ENDS
;	COMDAT ?get_room@VBuffer@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4
?get_room@VBuffer@@QAEJXZ PROC NEAR			; VBuffer::get_room, COMDAT

; 183  : 	I32 get_room(void){return (size-lock_end)/(state.vsize*4);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	sub	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	shr	ecx, 3
	and	ecx, 31					; 0000001fH
	shl	ecx, 2
	xor	edx, edx
	div	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?get_room@VBuffer@@QAEJXZ ENDP				; VBuffer::get_room
_TEXT	ENDS
;	COMDAT ??0VBManState@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0VBManState@@QAE@XZ PROC NEAR				; VBManState::VBManState, COMDAT

; 194  : 	VBManState(void) : in_prim(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VBManState@@QAE@XZ ENDP				; VBManState::VBManState
_TEXT	ENDS
PUBLIC	?begin_frame@PrimBuffer@@QAEXXZ			; PrimBuffer::begin_frame
_DATA	SEGMENT
	ORG $+3
$SG65304 DB	'D:\Games\duke_nukem_forever\Hacked\MeshEd\vidd3d\vbuffer'
	DB	'.cpp', 00H
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -4
?begin_frame@PrimBuffer@@QAEXXZ PROC NEAR		; PrimBuffer::begin_frame

; 119  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
$L65298:

; 120  : 	D_ASSERT(prim==(PrimD3D *)base);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $L65302
	push	120					; 00000078H
	push	OFFSET FLAT:$SG65304
	call	?_d_assert@@YAXPBDK@Z			; _d_assert
	add	esp, 8
$L65302:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L65298

; 121  : 	
; 122  : 	reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@PrimBuffer@@QAEXXZ		; PrimBuffer::reset

; 123  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?begin_frame@PrimBuffer@@QAEXXZ ENDP			; PrimBuffer::begin_frame
_TEXT	ENDS
PUBLIC	?BeginNewFrame@VManager@@QAEXXZ			; VManager::BeginNewFrame
_TEXT	SEGMENT
_this$ = -8
_start$ = -4
?BeginNewFrame@VManager@@QAEXXZ PROC NEAR		; VManager::BeginNewFrame

; 126  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 	VBuffer *start;
; 128  : 
; 129  : 	prims->begin_frame();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	call	?begin_frame@PrimBuffer@@QAEXXZ		; PrimBuffer::begin_frame

; 130  : 
; 131  : 	start=cur;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _start$[ebp], edx
$L65310:

; 134  : 		cur->begin_frame();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?begin_frame@VBuffer@@QAEXXZ		; VBuffer::begin_frame

; 135  : 		cur=cur->next;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 136  : 	}while(start!=cur);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $L65310

; 137  : 
; 138  : 	cur=start->next;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _start$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 139  : 	cur->select();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?select@VBuffer@@QAEXXZ			; VBuffer::select

; 140  : 	vindex=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 141  : 	room=cur->get_room();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?get_room@VBuffer@@QAEJXZ		; VBuffer::get_room
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 142  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BeginNewFrame@VManager@@QAEXXZ ENDP			; VManager::BeginNewFrame
_TEXT	ENDS
PUBLIC	?alloc_vbuffer@VManager@@IAEPAVVBuffer@@PAV2@K@Z ; VManager::alloc_vbuffer
_TEXT	SEGMENT
$T65842 = -8
_after$ = 8
_this$ = -12
_obj$ = -4
?alloc_vbuffer@VManager@@IAEPAVVBuffer@@PAV2@K@Z PROC NEAR ; VManager::alloc_vbuffer

; 145  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 	VBuffer *obj=new VBuffer(dev,cur->fvf,cur->count);

	push	56					; 00000038H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T65842[ebp], eax
	cmp	DWORD PTR $T65842[ebp], 0
	je	SHORT $L65843
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR $T65842[ebp]
	call	??0VBuffer@@QAE@PAUIDirect3DDevice8@@KK@Z ; VBuffer::VBuffer
	mov	DWORD PTR -16+[ebp], eax
	jmp	SHORT $L65844
$L65843:
	mov	DWORD PTR -16+[ebp], 0
$L65844:
	mov	edx, DWORD PTR -16+[ebp]
	mov	DWORD PTR _obj$[ebp], edx

; 147  : 
; 148  : 	insert_after(after,obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _after$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert_after@?$XRingChain@VVBuffer@@@@QAEPAVVBuffer@@PAV2@0@Z ; XRingChain<VBuffer>::insert_after

; 149  : 
; 150  : 	return obj;

	mov	eax, DWORD PTR _obj$[ebp]

; 151  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?alloc_vbuffer@VManager@@IAEPAVVBuffer@@PAV2@K@Z ENDP	; VManager::alloc_vbuffer
_TEXT	ENDS
PUBLIC	?is_finished@VBuffer@@QAEKXZ			; VBuffer::is_finished
PUBLIC	?MakeRoom@VManager@@IAEXK@Z			; VManager::MakeRoom
PUBLIC	?flush@VManager@@QAEXXZ				; VManager::flush
_TEXT	SEGMENT
_need$ = 8
_this$ = -12
_vb_room$65328 = -4
_tmp$65330 = -8
?MakeRoom@VManager@@IAEXK@Z PROC NEAR			; VManager::MakeRoom

; 154  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
$L65325:

; 157  : 		I32 vb_room=cur->get_room();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?get_room@VBuffer@@QAEJXZ		; VBuffer::get_room
	mov	DWORD PTR _vb_room$65328[ebp], eax

; 158  : 
; 159  : 		room=vb_room;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vb_room$65328[ebp]
	mov	DWORD PTR [ecx+20], edx

; 160  : 
; 161  : 		/* we actually have enough room */
; 162  : 		if ((room-=need)>=0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR _need$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jl	SHORT $L65329

; 163  : 			return;

	jmp	$L65324
$L65329:

; 164  : 
; 165  : 		/* flush existing data */
; 166  : 		flush();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?flush@VManager@@QAEXXZ			; VManager::flush

; 167  : 		/* mark current vbuffer as finished for this frame */
; 168  : 		cur->finished();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?finished@VBuffer@@QAEXXZ		; VBuffer::finished

; 169  : 		/* loop through looking for a vbuffer that is unfinished */
; 170  : 		VBuffer *tmp=cur;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _tmp$65330[ebp], eax

; 171  : 		cur=cur->next;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$L65332:

; 172  : 		while(tmp!=cur)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tmp$65330[ebp]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $L65333

; 174  : 			if (!cur->is_finished())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?is_finished@VBuffer@@QAEKXZ		; VBuffer::is_finished
	test	eax, eax
	jne	SHORT $L65334

; 175  : 				break;

	jmp	SHORT $L65333
$L65334:

; 176  : 			cur=cur->next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 177  : 		}

	jmp	SHORT $L65332
$L65333:

; 178  : 		if (cur->is_finished())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?is_finished@VBuffer@@QAEKXZ		; VBuffer::is_finished
	test	eax, eax
	je	SHORT $L65335

; 179  : 			cur=alloc_vbuffer(tmp,need);

	mov	ecx, DWORD PTR _need$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmp$65330[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?alloc_vbuffer@VManager@@IAEPAVVBuffer@@PAV2@K@Z ; VManager::alloc_vbuffer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L65335:

; 180  : 		/* select buffer for rendering */
; 181  : 		cur->select();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?select@VBuffer@@QAEXXZ			; VBuffer::select

; 182  : 		vindex=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 183  : 	}while(1);

	mov	ecx, 1
	test	ecx, ecx
	jne	$L65325
$L65324:

; 184  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MakeRoom@VManager@@IAEXK@Z ENDP			; VManager::MakeRoom
_TEXT	ENDS
;	COMDAT ?is_finished@VBuffer@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4
?is_finished@VBuffer@@QAEKXZ PROC NEAR			; VBuffer::is_finished, COMDAT

; 184  : 	U32 is_finished(void){return state.is_finished;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	shr	eax, 1
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?is_finished@VBuffer@@QAEKXZ ENDP			; VBuffer::is_finished
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4
?flush@VManager@@QAEXXZ PROC NEAR			; VManager::flush

; 187  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 188  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?flush@VManager@@QAEXXZ ENDP				; VManager::flush
_TEXT	ENDS
PUBLIC	?EndScene@VManager@@QAEXXZ			; VManager::EndScene
_TEXT	SEGMENT
_this$ = -4
?EndScene@VManager@@QAEXXZ PROC NEAR			; VManager::EndScene

; 191  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 192  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EndScene@VManager@@QAEXXZ ENDP				; VManager::EndScene
_TEXT	ENDS
;	COMDAT ??0?$XRingChain@VVBuffer@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$XRingChain@VVBuffer@@@@QAE@XZ PROC NEAR		; XRingChain<VBuffer>::XRingChain<VBuffer>, COMDAT

; 978  : 	XRingChain(void) : cur(null),count(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$XRingChain@VVBuffer@@@@QAE@XZ ENDP			; XRingChain<VBuffer>::XRingChain<VBuffer>
_TEXT	ENDS
;	COMDAT ?insert_after@?$XRingChain@VVBuffer@@@@QAEPAVVBuffer@@PAV2@0@Z
_TEXT	SEGMENT
_this$ = -8
_next$ = -4
_prev$ = 8
_ptr$ = 12
?insert_after@?$XRingChain@VVBuffer@@@@QAEPAVVBuffer@@PAV2@0@Z PROC NEAR ; XRingChain<VBuffer>::insert_after, COMDAT

; 1022 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1023 : 	cur=ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 1024 : 	if (!prev)

	cmp	DWORD PTR _prev$[ebp], 0
	jne	SHORT $L65538

; 1026 : 		ptr->next=ptr;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx], eax

; 1027 : 		ptr->prev=ptr;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 1028 : 		return ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	jmp	SHORT $L65537
$L65538:

; 1030 : 	
; 1031 : 	TYPE *next=prev->next;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _next$[ebp], ecx

; 1032 : 
; 1033 : 	ptr->next=next;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR [edx], eax

; 1034 : 	next->prev=ptr;

	mov	ecx, DWORD PTR _next$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 1035 : 	prev->next=ptr;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 1036 : 	ptr->prev=prev;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR _prev$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1037 : 
; 1038 : 	return cur;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
$L65537:

; 1039 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?insert_after@?$XRingChain@VVBuffer@@@@QAEPAVVBuffer@@PAV2@0@Z ENDP ; XRingChain<VBuffer>::insert_after
_TEXT	ENDS
END
